<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>Untitled.html</title>
  <meta name="generator" content="Haroopad 0.12.2" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>div.oembedall-githubrepos{border:1px solid #DDD;border-radius:4px;list-style-type:none;margin:0 0 10px;padding:8px 10px 0;font:13.34px/1.4 helvetica,arial,freesans,clean,sans-serif;width:452px;background-color:#fff}div.oembedall-githubrepos .oembedall-body{background:-moz-linear-gradient(center top,#FAFAFA,#EFEFEF) repeat scroll 0 0 transparent;background:-webkit-gradient(linear,left top,left bottom,from(#FAFAFA),to(#EFEFEF));border-bottom-left-radius:4px;border-bottom-right-radius:4px;border-top:1px solid #EEE;margin-left:-10px;margin-top:8px;padding:5px 10px;width:100%}div.oembedall-githubrepos h3{font-size:14px;margin:0;padding-left:18px;white-space:nowrap}div.oembedall-githubrepos p.oembedall-description{color:#444;font-size:12px;margin:0 0 3px}div.oembedall-githubrepos p.oembedall-updated-at{color:#888;font-size:11px;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats{border:medium none;float:right;font-size:11px;font-weight:700;padding-left:15px;position:relative;z-index:5;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats li{border:medium none;color:#666;display:inline-block;list-style-type:none;margin:0!important}div.oembedall-githubrepos ul.oembedall-repo-stats li a{background-color:transparent;border:medium none;color:#666!important;background-position:5px -2px;background-repeat:no-repeat;border-left:1px solid #DDD;display:inline-block;height:21px;line-height:21px;padding:0 5px 0 23px}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a{border-left:medium none;margin-right:-3px}div.oembedall-githubrepos ul.oembedall-repo-stats li a:hover{background:none no-repeat scroll 5px -27px #4183C4;color:#FFF!important;text-decoration:none}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a:hover{border-bottom-left-radius:3px;border-top-left-radius:3px}ul.oembedall-repo-stats li:last-child a:hover{border-bottom-right-radius:3px;border-top-right-radius:3px}span.oembedall-closehide{background-color:#aaa;border-radius:2px;cursor:pointer;margin-right:3px}div.oembedall-container{margin-top:5px;text-align:left}.oembedall-ljuser{font-weight:700}.oembedall-ljuser img{vertical-align:bottom;border:0;padding-right:1px}.oembedall-stoqembed{border-bottom:1px dotted #999;float:left;overflow:hidden;width:730px;line-height:1;background:none repeat scroll 0 0 #FFF;color:#000;font-family:Arial,Liberation Sans,DejaVu Sans,sans-serif;font-size:80%;text-align:left;margin:0;padding:0}.oembedall-stoqembed a{color:#07C;text-decoration:none;margin:0;padding:0}.oembedall-stoqembed a:hover{text-decoration:underline}.oembedall-stoqembed a:visited{color:#4A6B82}.oembedall-stoqembed h3{font-family:Trebuchet MS,Liberation Sans,DejaVu Sans,sans-serif;font-size:130%;font-weight:700;margin:0;padding:0}.oembedall-stoqembed .oembedall-reputation-score{color:#444;font-size:120%;font-weight:700;margin-right:2px}.oembedall-stoqembed .oembedall-user-info{height:35px;width:185px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-gravatar32{float:left;height:32px;width:32px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-details{float:left;margin-left:5px;overflow:hidden;white-space:nowrap;width:145px}.oembedall-stoqembed .oembedall-question-hyperlink{font-weight:700}.oembedall-stoqembed .oembedall-stats{background:none repeat scroll 0 0 #EEE;margin:0 0 0 7px;padding:4px 7px 6px;width:58px}.oembedall-stoqembed .oembedall-statscontainer{float:left;margin-right:8px;width:86px}.oembedall-stoqembed .oembedall-votes{color:#555;padding:0 0 7px;text-align:center}.oembedall-stoqembed .oembedall-vote-count-post{font-size:240%;color:#808185;display:block;font-weight:700}.oembedall-stoqembed .oembedall-views{color:#999;padding-top:4px;text-align:center}.oembedall-stoqembed .oembedall-status{margin-top:-3px;padding:4px 0;text-align:center;background:none repeat scroll 0 0 #75845C;color:#FFF}.oembedall-stoqembed .oembedall-status strong{color:#FFF;display:block;font-size:140%}.oembedall-stoqembed .oembedall-summary{float:left;width:635px}.oembedall-stoqembed .oembedall-excerpt{line-height:1.2;margin:0;padding:0 0 5px}.oembedall-stoqembed .oembedall-tags{float:left;line-height:18px}.oembedall-stoqembed .oembedall-tags a:hover{text-decoration:none}.oembedall-stoqembed .oembedall-post-tag{background-color:#E0EAF1;border-bottom:1px solid #3E6D8E;border-right:1px solid #7F9FB6;color:#3E6D8E;font-size:90%;line-height:2.4;margin:2px 2px 2px 0;padding:3px 4px;text-decoration:none;white-space:nowrap}.oembedall-stoqembed .oembedall-post-tag:hover{background-color:#3E6D8E;border-bottom:1px solid #37607D;border-right:1px solid #37607D;color:#E0EAF1}.oembedall-stoqembed .oembedall-fr{float:right}.oembedall-stoqembed .oembedall-statsarrow{background-image:url(http://cdn.sstatic.net/stackoverflow/img/sprites.png?v=3);background-repeat:no-repeat;overflow:hidden;background-position:0 -435px;float:right;height:13px;margin-top:12px;width:7px}.oembedall-facebook1{border:#1A3C6C solid 1px;padding:0;font:13.34px/1.4 verdana;width:500px}.oembedall-facebook2{background-color:#627add}.oembedall-facebook2 a{color:#e8e8e8;text-decoration:none}.oembedall-facebookBody{background-color:#fff;vertical-align:top;padding:5px}.oembedall-facebookBody .contents{display:inline-block;width:100%}.oembedall-facebookBody div img{float:left;margin-right:5px}div.oembedall-lanyard{-webkit-box-shadow:none;-webkit-transition-delay:0s;-webkit-transition-duration:.4000000059604645s;-webkit-transition-property:width;-webkit-transition-timing-function:cubic-bezier(0.42,0,.58,1);background-attachment:scroll;background-clip:border-box;background-color:transparent;background-image:none;background-origin:padding-box;border-bottom-width:0;border-left-width:0;border-right-width:0;border-top-width:0;box-shadow:none;color:#112644;display:block;float:left;font-family:'Trebuchet MS',Trebuchet,sans-serif;font-size:16px;height:253px;line-height:19px;margin-bottom:0;margin-left:0;margin-right:0;margin-top:0;max-width:none;min-height:0;outline-color:#112644;outline-style:none;outline-width:0;overflow-x:visible;overflow-y:visible;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;position:relative;text-align:left;vertical-align:baseline;width:804px}div.oembedall-lanyard .tagline{font-size:1.5em}div.oembedall-lanyard .wrapper{overflow:hidden;clear:both}div.oembedall-lanyard .split{float:left;display:inline}div.oembedall-lanyard .prominent-place .flag:active,div.oembedall-lanyard .prominent-place .flag:focus,div.oembedall-lanyard .prominent-place .flag:hover,div.oembedall-lanyard .prominent-place .flag:link,div.oembedall-lanyard .prominent-place .flag:visited{float:left;display:block;width:48px;height:48px;position:relative;top:-5px;margin-right:10px}div.oembedall-lanyard .place-context{font-size:.889em}div.oembedall-lanyard .prominent-place .sub-place{display:block}div.oembedall-lanyard .prominent-place{font-size:1.125em;line-height:1.1em;font-weight:400}div.oembedall-lanyard .main-date{color:#8CB4E0;font-weight:700;line-height:1.1}div.oembedall-lanyard .first{width:48.57%;margin:0 0 0 2.857%}html{height:100%}body{margin:0!important;padding:5px 20px 26px!important;background-color:#fff;font-family:"Lucida Grande","Segoe UI","Apple SD Gothic Neo","Malgun Gothic","Lucida Sans Unicode",Helvetica,Arial,sans-serif;font-size:.9em;overflow-x:hidden;overflow-y:auto}br,h1,h2,h3,h4,h5,h6{clear:both}hr.page{background:transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;border:0 none;color:#ccc;height:3px;padding:0}hr.underscore{border:0 none!important;height:30px;padding:0;-webkit-margin-before:0;-webkit-margin-after:0}body >:first-child{margin-top:0!important}img.plugin{box-shadow:0 1px 3px rgba(0,0,0,.1);border-radius:3px}iframe{border:0}figure{-webkit-margin-before:0;-webkit-margin-after:0;-webkit-margin-start:0;-webkit-margin-end:0}kbd{border:1px solid #aaa;-moz-border-radius:2px;-webkit-border-radius:2px;border-radius:2px;-moz-box-shadow:1px 2px 2px #ddd;-webkit-box-shadow:1px 2px 2px #ddd;box-shadow:1px 2px 2px #ddd;background-color:#f9f9f9;background-image:-moz-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-o-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-webkit-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:linear-gradient(top,#eee,#f9f9f9,#eee);padding:1px 3px;font-family:inherit;font-size:.85em}.oembeded .oembed_photo{display:inline-block}img[data-echo]{margin:25px 0;width:100px;height:100px;background:#fff url(../img/ajax.gif) no-repeat center center}.spinner{display:inline-block;width:10px;height:10px;margin-bottom:-.1em;border:2px solid rgba(0,0,0,.5);border-top-color:transparent;border-radius:100%;-webkit-animation:spin 1s infinite linear;animation:spin 1s infinite linear}.spinner:after{content:'';display:block;width:0;height:0;position:absolute;top:-6px;left:0;border:4px solid transparent;border-bottom-color:rgba(0,0,0,.5);-webkit-transform:rotate(45deg);transform:rotate(45deg)}@-webkit-keyframes spin{to{-webkit-transform:rotate(360deg)}}@keyframes spin{to{transform:rotate(360deg)}}p.toc{margin:0!important}p.toc ul{padding-left:10px}p.toc>ul{padding:10px;margin:0 10px;display:inline-block;border:1px solid #ededed;border-radius:5px}p.toc li,p.toc ul{list-style-type:none}p.toc li{width:100%;padding:0;overflow:hidden}p.toc li a::after{content:"."}p.toc li a:before{content:"• "}p.toc h5{text-transform:uppercase}p.toc .title{float:left;padding-right:3px}p.toc .number{margin:0;float:right;padding-left:3px;background:#fff;display:none}.markdown{padding:20px}.markdown a{text-decoration:none;vertical-align:baseline}.markdown a:hover{text-decoration:underline}.markdown h1{font-size:2.2em;font-weight:700;margin:1.5em 0 1em}.markdown h2{font-size:1.8em;font-weight:700;margin:1.275em 0 .85em}.markdown h3{font-size:1.6em;font-weight:700;margin:1.125em 0 .75em}.markdown h4{font-size:1.4em;font-weight:700;margin:.99em 0 .66em}.markdown h5{font-size:1.2em;font-weight:700;margin:.855em 0 .57em}.markdown h6{font-size:1em;font-weight:700;margin:.75em 0 .5em}.markdown h1+p,.markdown h1:first-child,.markdown h2+p,.markdown h2:first-child,.markdown h3+p,.markdown h3:first-child,.markdown h4+p,.markdown h4:first-child,.markdown h5+p,.markdown h5:first-child,.markdown h6+p,.markdown h6:first-child{margin-top:0}.markdown hr{border:1px solid #ccc}.markdown p{margin:1em 0;word-wrap:break-word}.markdown ol{list-style-type:decimal}.markdown li{display:list-item;line-height:1.4em}.markdown blockquote{margin:1em 20px}.markdown blockquote>:first-child{margin-top:0}.markdown blockquote>:last-child{margin-bottom:0}.markdown blockquote cite:before{content:'\2014 \00A0'}.markdown .code{border-radius:3px;word-break:break-all;word-wrap:break-word}.markdown pre{border-radius:3px;word-break:break-all;word-wrap:break-word;overflow:auto}.markdown pre code{display:block}.markdown pre>code{border:1px solid #ccc;white-space:pre;padding:.5em;margin:0}.markdown code{border-radius:3px;word-break:break-all;word-wrap:break-word;border:1px solid #ccc;padding:0 5px;margin:0 2px}.markdown img{max-width:100%}.markdown table{padding:0;border-collapse:collapse;border-spacing:0}.markdown table tr td,.markdown table tr th{border:1px solid #ccc;margin:0;padding:6px 13px}.markdown table tr th{font-weight:700}.markdown table tr th>:first-child{margin-top:0}.markdown table tr th>:last-child{margin-bottom:0}.markdown table tr td>:first-child{margin-top:0}.markdown table tr td>:last-child{margin-bottom:0}.markdown em.underline{font-style:normal;text-decoration:underline}.markdown strong.highlight{color:#000;padding:0 5px;background-color:#fdffb6;-webkit-box-shadow:#fdffb6 0 0 5px;-moz-box-shadow:#fdffb6 0 0 5px;box-shadow:#fdffb6 0 0 5px}.clearness-dark{padding:20px;color:#fff;font-size:15px;font-family:"Lucida Grande","Lucida Sans Unicode","Lucida Sans",AppleSDGothicNeo-Medium,'Segoe UI','Malgun Gothic',Verdana,Tahoma,sans-serif;background:#282a36;-webkit-font-smoothing:antialiased}.clearness-dark a{color:#e03300}.clearness-dark a:hover{color:#ff4a14}.clearness-dark h2{border-bottom:1px solid #21232d;line-height:1.7em}.clearness-dark h6{color:#a4a296}.clearness-dark hr{border:1px solid #21232d}.clearness-dark pre>code{font-size:.9em;font-family:Consolas,Inconsolata,Courier,monospace}.clearness-dark blockquote{border-left:4px solid #121319;padding:0 15px;font-style:italic}.clearness-dark table{background-color:#303241}.clearness-dark table tr td,.clearness-dark table tr th{border:1px solid #4b4e65}.clearness-dark table tr:nth-child(2n){background-color:#373a4b}.hljs{display:block;overflow-x:auto;padding:.5em;background:#23241f;-webkit-text-size-adjust:none}.css .hljs-function .hljs-preprocessor,.css .hljs-rules,.css .hljs-value,.hljs,.hljs-pragma,.hljs-tag{color:#f8f8f2}.hljs-emphasis,.hljs-strong,.hljs-strongemphasis{color:#a8a8a2}.alias .hljs-keyword,.hljs-blockquote,.hljs-bullet,.hljs-hexcolor,.hljs-horizontal_rule,.hljs-literal,.hljs-number,.hljs-regexp{color:#ae81ff}.css .hljs-class,.hljs-class .hljs-title:last-child,.hljs-code,.hljs-tag .hljs-value,.hljs-title{color:#a6e22e}.hljs-link_url{font-size:80%}.hljs-strong,.hljs-strongemphasis{font-weight:700}.hljs-class .hljs-title:last-child,.hljs-emphasis,.hljs-strongemphasis{font-style:italic}.alias .hljs-keyword:first-child,.clojure .hljs-built_in,.css .hljs-important,.css .hljs-tag,.css .unit,.hljs-attribute,.hljs-change,.hljs-flow,.hljs-function,.hljs-header,.hljs-keyword,.hljs-symbol,.hljs-symbol .hljs-string,.hljs-tag .hljs-title,.hljs-value,.hljs-winutils,.lisp .hljs-title,.nginx .hljs-title,.tex .hljs-special{color:#f92672}.css .hljs-attribute,.hljs-class .hljs-keyword:first-child,.hljs-constant,.hljs-function .hljs-keyword{color:#66d9ef}.hljs-class .hljs-title,.hljs-params,.hljs-variable{color:#f8f8f2}.apache .hljs-cbracket,.apache .hljs-tag,.css .hljs-id,.django .hljs-filter .hljs-argument,.django .hljs-template_tag,.django .hljs-variable,.hljs-addition,.hljs-attr_selector,.hljs-built_in,.hljs-envvar,.hljs-link_label,.hljs-link_url,.hljs-prompt,.hljs-pseudo,.hljs-stream,.hljs-string,.hljs-subst,.hljs-type,.ruby .hljs-class .hljs-parent,.smalltalk .hljs-array,.smalltalk .hljs-class,.smalltalk .hljs-localvars,.tex .hljs-command{color:#e6db74}.apache .hljs-sqbracket,.hljs-comment,.hljs-deletion,.hljs-doctype,.hljs-javadoc,.hljs-pi,.hljs-shebang,.hljs-template_comment,.java .hljs-annotation,.python .hljs-decorator,.tex .hljs-formula{color:#75715e}.coffeescript .javascript,.javascript .xml,.php .xml,.tex .hljs-formula,.xml .css,.xml .hljs-cdata,.xml .javascript,.xml .php,.xml .vbscript{opacity:.5}footer{position:fixed;font-size:.8em;text-align:right;bottom:0;margin-left:-25px;height:20px;width:100%}</style>
</head>
<body class="markdown clearness-dark">

  <h1 id="async.js"><a name="async.js" href="#async.js"></a>Async.js</h1><p><a href="https://travis-ci.org/caolan/async"><img src="https://travis-ci.org/caolan/async.svg?branch=master" alt="Build Status via Travis CI"></a></p><p>Async is a utility module which provides straight-forward, powerful functions<br>for working with asynchronous JavaScript. Although originally designed for<br>use with <a href="http://nodejs.org">Node.js</a>, it can also be used directly in the<br>browser. Also supports <a href="https://github.com/component/component">component</a>.</p><p>Async provides around 20 functions that include the usual ‘functional’<br>suspects (<code>map</code>, <code>reduce</code>, <code>filter</code>, <code>each</code>…) as well as some common patterns<br>for asynchronous control flow (<code>parallel</code>, <code>series</code>, <code>waterfall</code>…). All these<br>functions assume you follow the Node.js convention of providing a single<br>callback as the last argument of your <code>async</code> function.</p><h2 id="quick-examples"><a name="quick-examples" href="#quick-examples"></a>Quick Examples</h2><pre><code class="javascript hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;async.map(['file1','file2','file3'], fs.stat, function(err, results){
    // results is now an array of stats for each file
});

async.filter(['file1','file2','file3'], fs.exists, function(results){
    // results now equals an array of the existing files
});

async.parallel([
    function(){ ... },
    function(){ ... }
], callback);

async.series([
    function(){ ... },
    function(){ ... }
]);
&lt;/code&gt;&lt;/pre&gt;">async.map([<span class="hljs-string">'file1'</span>,<span class="hljs-string">'file2'</span>,<span class="hljs-string">'file3'</span>], fs.stat, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, results)</span></span>{
    <span class="hljs-comment">// results is now an array of stats for each file</span>
});

async.filter([<span class="hljs-string">'file1'</span>,<span class="hljs-string">'file2'</span>,<span class="hljs-string">'file3'</span>], fs.exists, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(results)</span></span>{
    <span class="hljs-comment">// results now equals an array of the existing files</span>
});

async.parallel([
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{ ... },
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{ ... }
], callback);

async.series([
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{ ... },
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{ ... }
]);
</code></pre><p>There are many more functions available so take a look at the docs below for a<br>full list. This module aims to be comprehensive, so if you feel anything is<br>missing please create a GitHub issue for it.</p><h2 id="common-pitfalls"><a name="common-pitfalls" href="#common-pitfalls"></a>Common Pitfalls</h2><h3 id="binding-a-context-to-an-iterator"><a name="binding-a-context-to-an-iterator" href="#binding-a-context-to-an-iterator"></a>Binding a context to an iterator</h3><p>This section is really about <code>bind</code>, not about <code>async</code>. If you are wondering how to<br>make <code>async</code> execute your iterators in a given context, or are confused as to why<br>a method of another library isn’t working as an iterator, study this example:</p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;// Here is a simple object with an (unnecessarily roundabout) squaring method
var AsyncSquaringLibrary = {
  squareExponent: 2,
  square: function(number, callback){ 
    var result = Math.pow(number, this.squareExponent);
    setTimeout(function(){
      callback(null, result);
    }, 200);
  }
};

async.map([1, 2, 3], AsyncSquaringLibrary.square, function(err, result){
  // result is [NaN, NaN, NaN]
  // This fails because the `this.squareExponent` expression in the square
  // function is not evaluated in the context of AsyncSquaringLibrary, and is
  // therefore undefined.
});

async.map([1, 2, 3], AsyncSquaringLibrary.square.bind(AsyncSquaringLibrary), function(err, result){
  // result is [1, 4, 9]
  // With the help of bind we can attach a context to the iterator before
  // passing it to async. Now the square function will be executed in its 
  // 'home' AsyncSquaringLibrary context and the value of `this.squareExponent`
  // will be as expected.
});
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-comment">// Here is a simple object with an (unnecessarily roundabout) squaring method</span>
<span class="hljs-keyword">var</span> AsyncSquaringLibrary = {
  squareExponent: <span class="hljs-number">2</span>,
  square: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(number, callback)</span></span>{ 
    <span class="hljs-keyword">var</span> result = <span class="hljs-built_in">Math</span>.pow(number, <span class="hljs-keyword">this</span>.squareExponent);
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
      callback(<span class="hljs-literal">null</span>, result);
    }, <span class="hljs-number">200</span>);
  }
};

async.map([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], AsyncSquaringLibrary.square, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, result)</span></span>{
  <span class="hljs-comment">// result is [NaN, NaN, NaN]</span>
  <span class="hljs-comment">// This fails because the `this.squareExponent` expression in the square</span>
  <span class="hljs-comment">// function is not evaluated in the context of AsyncSquaringLibrary, and is</span>
  <span class="hljs-comment">// therefore undefined.</span>
});

async.map([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], AsyncSquaringLibrary.square.bind(AsyncSquaringLibrary), <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, result)</span></span>{
  <span class="hljs-comment">// result is [1, 4, 9]</span>
  <span class="hljs-comment">// With the help of bind we can attach a context to the iterator before</span>
  <span class="hljs-comment">// passing it to async. Now the square function will be executed in its </span>
  <span class="hljs-comment">// 'home' AsyncSquaringLibrary context and the value of `this.squareExponent`</span>
  <span class="hljs-comment">// will be as expected.</span>
});
</code></pre><h2 id="download"><a name="download" href="#download"></a>Download</h2><p>The source is available for download from<br><a href="http://github.com/caolan/async">GitHub</a>.<br>Alternatively, you can install using Node Package Manager (<code>npm</code>):</p><pre><code data-origin="&lt;pre&gt;&lt;code&gt;npm install async
&lt;/code&gt;&lt;/pre&gt;">npm install async
</code></pre><p><strong>Development:</strong> <a href="https://github.com/caolan/async/raw/master/lib/async.js">async.js</a> - 29.6kb Uncompressed</p><h2 id="in-the-browser"><a name="in-the-browser" href="#in-the-browser"></a>In the Browser</h2><p>So far it’s been tested in IE6, IE7, IE8, FF3.6 and Chrome 5. </p><p>Usage:</p><pre><code class="html hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;async.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;

    async.map(data, asyncProcess, function(err, results){
        alert(results);
    });

&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"async.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">

    async.map(data, asyncProcess, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, results)</span></span>{
        alert(results);
    });

</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre><h2 id="documentation"><a name="documentation" href="#documentation"></a>Documentation</h2><h3 id="collections"><a name="collections" href="#collections"></a>Collections</h3><ul>
<li><a href="#each"><code>each</code></a></li>
<li><a href="#eachSeries"><code>eachSeries</code></a></li>
<li><a href="#eachLimit"><code>eachLimit</code></a></li>
<li><a href="#map"><code>map</code></a></li>
<li><a href="#mapSeries"><code>mapSeries</code></a></li>
<li><a href="#mapLimit"><code>mapLimit</code></a></li>
<li><a href="#filter"><code>filter</code></a></li>
<li><a href="#filterSeries"><code>filterSeries</code></a></li>
<li><a href="#reject"><code>reject</code></a></li>
<li><a href="#rejectSeries"><code>rejectSeries</code></a></li>
<li><a href="#reduce"><code>reduce</code></a></li>
<li><a href="#reduceRight"><code>reduceRight</code></a></li>
<li><a href="#detect"><code>detect</code></a></li>
<li><a href="#detectSeries"><code>detectSeries</code></a></li>
<li><a href="#sortBy"><code>sortBy</code></a></li>
<li><a href="#some"><code>some</code></a></li>
<li><a href="#every"><code>every</code></a></li>
<li><a href="#concat"><code>concat</code></a></li>
<li><a href="#concatSeries"><code>concatSeries</code></a></li>
</ul><h3 id="control-flow"><a name="control-flow" href="#control-flow"></a>Control Flow</h3><ul>
<li><a href="#seriestasks-callback"><code>series</code></a></li>
<li><a href="#parallel"><code>parallel</code></a></li>
<li><a href="#parallellimittasks-limit-callback"><code>parallelLimit</code></a></li>
<li><a href="#whilst"><code>whilst</code></a></li>
<li><a href="#doWhilst"><code>doWhilst</code></a></li>
<li><a href="#until"><code>until</code></a></li>
<li><a href="#doUntil"><code>doUntil</code></a></li>
<li><a href="#forever"><code>forever</code></a></li>
<li><a href="#waterfall"><code>waterfall</code></a></li>
<li><a href="#compose"><code>compose</code></a></li>
<li><a href="#seq"><code>seq</code></a></li>
<li><a href="#applyEach"><code>applyEach</code></a></li>
<li><a href="#applyEachSeries"><code>applyEachSeries</code></a></li>
<li><a href="#queue"><code>queue</code></a></li>
<li><a href="#priorityQueue"><code>priorityQueue</code></a></li>
<li><a href="#cargo"><code>cargo</code></a></li>
<li><a href="#auto"><code>auto</code></a></li>
<li><a href="#retry"><code>retry</code></a></li>
<li><a href="#iterator"><code>iterator</code></a></li>
<li><a href="#apply"><code>apply</code></a></li>
<li><a href="#nextTick"><code>nextTick</code></a></li>
<li><a href="#times"><code>times</code></a></li>
<li><a href="#timesSeries"><code>timesSeries</code></a></li>
</ul><h3 id="utils"><a name="utils" href="#utils"></a>Utils</h3><ul>
<li><a href="#memoize"><code>memoize</code></a></li>
<li><a href="#unmemoize"><code>unmemoize</code></a></li>
<li><a href="#log"><code>log</code></a></li>
<li><a href="#dir"><code>dir</code></a></li>
<li><a href="#noConflict"><code>noConflict</code></a></li>
</ul><h2 id="collections"><a name="collections" href="#collections"></a>Collections</h2><p><a name="forEach"><br></a><a name="each"></a></p><a name="each">
</a><h3 id="each(arr,-iterator,-callback)"><a name="each"></a><a name="each(arr,-iterator,-callback)" href="#each(arr,-iterator,-callback)"></a>each(arr, iterator, callback)</h3><p>Applies the function <code>iterator</code> to each item in <code>arr</code>, in parallel.<br>The <code>iterator</code> is called with an item from the list, and a callback for when it<br>has finished. If the <code>iterator</code> passes an error to its <code>callback</code>, the main<br><code>callback</code> (for the <code>each</code> function) is immediately called with the error.</p><p>Note, that since this function applies <code>iterator</code> to each item in parallel,<br>there is no guarantee that the iterator functions will complete in order.</p><p><strong>Arguments</strong></p><ul>
<li><code>arr</code> - An array to iterate over.</li>
<li><code>iterator(item, callback)</code> - A function to apply to each item in <code>arr</code>.<br>The iterator is passed a <code>callback(err)</code> which must be called once it has<br>completed. If no error has occurred, the <code>callback</code> should be run without<br>arguments or with an explicit <code>null</code> argument.</li>
<li><code>callback(err)</code> - A callback which is called when all <code>iterator</code> functions<br>have finished, or an error occurs.</li>
</ul><p><strong>Examples</strong></p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;// assuming openFiles is an array of file names and saveFile is a function
// to save the modified contents of that file:

async.each(openFiles, saveFile, function(err){
    // if any of the saves produced an error, err would equal that error
});
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-comment">// assuming openFiles is an array of file names and saveFile is a function</span>
<span class="hljs-comment">// to save the modified contents of that file:</span>

async.each(openFiles, saveFile, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err)</span></span>{
    <span class="hljs-comment">// if any of the saves produced an error, err would equal that error</span>
});
</code></pre><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;// assuming openFiles is an array of file names 

async.each(openFiles, function( file, callback) {

  // Perform operation on file here.
  console.log('Processing file ' + file);

  if( file.length &amp;gt; 32 ) {
    console.log('This file name is too long');
    callback('File name too long');
  } else {
    // Do work to process file here
    console.log('File processed');
    callback();
  }
}, function(err){
    // if any of the file processing produced an error, err would equal that error
    if( err ) {
      // One of the iterations produced an error.
      // All processing will now stop.
      console.log('A file failed to process');
    } else {
      console.log('All files have been processed successfully');
    }
});
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-comment">// assuming openFiles is an array of file names </span>

async.each(openFiles, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( file, callback)</span> </span>{

  <span class="hljs-comment">// Perform operation on file here.</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Processing file '</span> + file);

  <span class="hljs-keyword">if</span>( file.length &gt; <span class="hljs-number">32</span> ) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'This file name is too long'</span>);
    callback(<span class="hljs-string">'File name too long'</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// Do work to process file here</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'File processed'</span>);
    callback();
  }
}, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err)</span></span>{
    <span class="hljs-comment">// if any of the file processing produced an error, err would equal that error</span>
    <span class="hljs-keyword">if</span>( err ) {
      <span class="hljs-comment">// One of the iterations produced an error.</span>
      <span class="hljs-comment">// All processing will now stop.</span>
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'A file failed to process'</span>);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'All files have been processed successfully'</span>);
    }
});
</code></pre><hr class="section"><p><a name="forEachSeries"><br></a><a name="eachSeries"></a></p><a name="eachSeries">
</a><h3 id="eachseries(arr,-iterator,-callback)"><a name="eachSeries"></a><a name="eachseries(arr,-iterator,-callback)" href="#eachseries(arr,-iterator,-callback)"></a>eachSeries(arr, iterator, callback)</h3><p>The same as <a href="#each"><code>each</code></a>, only <code>iterator</code> is applied to each item in <code>arr</code> in<br>series. The next <code>iterator</code> is only called once the current one has completed.<br>This means the <code>iterator</code> functions will complete in order.</p><hr class="section"><p><a name="forEachLimit"><br></a><a name="eachLimit"></a></p><a name="eachLimit">
</a><h3 id="eachlimit(arr,-limit,-iterator,-callback)"><a name="eachLimit"></a><a name="eachlimit(arr,-limit,-iterator,-callback)" href="#eachlimit(arr,-limit,-iterator,-callback)"></a>eachLimit(arr, limit, iterator, callback)</h3><p>The same as <a href="#each"><code>each</code></a>, only no more than <code>limit</code> <code>iterator</code>s will be simultaneously<br>running at any time.</p><p>Note that the items in <code>arr</code> are not processed in batches, so there is no guarantee that<br>the first <code>limit</code> <code>iterator</code> functions will complete before any others are started.</p><p><strong>Arguments</strong></p><ul>
<li><code>arr</code> - An array to iterate over.</li>
<li><code>limit</code> - The maximum number of <code>iterator</code>s to run at any time.</li>
<li><code>iterator(item, callback)</code> - A function to apply to each item in <code>arr</code>.<br>The iterator is passed a <code>callback(err)</code> which must be called once it has<br>completed. If no error has occurred, the callback should be run without<br>arguments or with an explicit <code>null</code> argument.</li>
<li><code>callback(err)</code> - A callback which is called when all <code>iterator</code> functions<br>have finished, or an error occurs.</li>
</ul><p><strong>Example</strong></p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;// Assume documents is an array of JSON objects and requestApi is a
// function that interacts with a rate-limited REST api.

async.eachLimit(documents, 20, requestApi, function(err){
    // if any of the saves produced an error, err would equal that error
});
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-comment">// Assume documents is an array of JSON objects and requestApi is a</span>
<span class="hljs-comment">// function that interacts with a rate-limited REST api.</span>

async.eachLimit(documents, <span class="hljs-number">20</span>, requestApi, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err)</span></span>{
    <span class="hljs-comment">// if any of the saves produced an error, err would equal that error</span>
});
</code></pre><hr class="section"><p><a name="map"></a></p><a name="map">
</a><h3 id="map(arr,-iterator,-callback)"><a name="map"></a><a name="map(arr,-iterator,-callback)" href="#map(arr,-iterator,-callback)"></a>map(arr, iterator, callback)</h3><p>Produces a new array of values by mapping each value in <code>arr</code> through<br>the <code>iterator</code> function. The <code>iterator</code> is called with an item from <code>arr</code> and a<br>callback for when it has finished processing. Each of these callback takes 2 arguments:<br>an <code>error</code>, and the transformed item from <code>arr</code>. If <code>iterator</code> passes an error to his<br>callback, the main <code>callback</code> (for the <code>map</code> function) is immediately called with the error.</p><p>Note, that since this function applies the <code>iterator</code> to each item in parallel,<br>there is no guarantee that the <code>iterator</code> functions will complete in order.<br>However, the results array will be in the same order as the original <code>arr</code>.</p><p><strong>Arguments</strong></p><ul>
<li><code>arr</code> - An array to iterate over.</li>
<li><code>iterator(item, callback)</code> - A function to apply to each item in <code>arr</code>.<br>The iterator is passed a <code>callback(err, transformed)</code> which must be called once<br>it has completed with an error (which can be <code>null</code>) and a transformed item.</li>
<li><code>callback(err, results)</code> - A callback which is called when all <code>iterator</code><br>functions have finished, or an error occurs. Results is an array of the<br>transformed items from the <code>arr</code>.</li>
</ul><p><strong>Example</strong></p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;async.map(['file1','file2','file3'], fs.stat, function(err, results){
    // results is now an array of stats for each file
});
&lt;/code&gt;&lt;/pre&gt;">async.map([<span class="hljs-string">'file1'</span>,<span class="hljs-string">'file2'</span>,<span class="hljs-string">'file3'</span>], fs.stat, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, results)</span></span>{
    <span class="hljs-comment">// results is now an array of stats for each file</span>
});
</code></pre><hr class="section"><p><a name="mapSeries"></a></p><a name="mapSeries">
</a><h3 id="mapseries(arr,-iterator,-callback)"><a name="mapSeries"></a><a name="mapseries(arr,-iterator,-callback)" href="#mapseries(arr,-iterator,-callback)"></a>mapSeries(arr, iterator, callback)</h3><p>The same as <a href="#map"><code>map</code></a>, only the <code>iterator</code> is applied to each item in <code>arr</code> in<br>series. The next <code>iterator</code> is only called once the current one has completed.<br>The results array will be in the same order as the original.</p><hr class="section"><p><a name="mapLimit"></a></p><a name="mapLimit">
</a><h3 id="maplimit(arr,-limit,-iterator,-callback)"><a name="mapLimit"></a><a name="maplimit(arr,-limit,-iterator,-callback)" href="#maplimit(arr,-limit,-iterator,-callback)"></a>mapLimit(arr, limit, iterator, callback)</h3><p>The same as <a href="#map"><code>map</code></a>, only no more than <code>limit</code> <code>iterator</code>s will be simultaneously<br>running at any time.</p><p>Note that the items are not processed in batches, so there is no guarantee that<br>the first <code>limit</code> <code>iterator</code> functions will complete before any others are started.</p><p><strong>Arguments</strong></p><ul>
<li><code>arr</code> - An array to iterate over.</li>
<li><code>limit</code> - The maximum number of <code>iterator</code>s to run at any time.</li>
<li><code>iterator(item, callback)</code> - A function to apply to each item in <code>arr</code>.<br>The iterator is passed a <code>callback(err, transformed)</code> which must be called once<br>it has completed with an error (which can be <code>null</code>) and a transformed item.</li>
<li><code>callback(err, results)</code> - A callback which is called when all <code>iterator</code><br>calls have finished, or an error occurs. The result is an array of the<br>transformed items from the original <code>arr</code>.</li>
</ul><p><strong>Example</strong></p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;async.mapLimit(['file1','file2','file3'], 1, fs.stat, function(err, results){
    // results is now an array of stats for each file
});
&lt;/code&gt;&lt;/pre&gt;">async.mapLimit([<span class="hljs-string">'file1'</span>,<span class="hljs-string">'file2'</span>,<span class="hljs-string">'file3'</span>], <span class="hljs-number">1</span>, fs.stat, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, results)</span></span>{
    <span class="hljs-comment">// results is now an array of stats for each file</span>
});
</code></pre><hr class="section"><p><a name="select"><br></a><a name="filter"></a></p><a name="filter">
</a><h3 id="filter(arr,-iterator,-callback)"><a name="filter"></a><a name="filter(arr,-iterator,-callback)" href="#filter(arr,-iterator,-callback)"></a>filter(arr, iterator, callback)</h3><p><strong>Alias:</strong> <code>select</code></p><p>Returns a new array of all the values in <code>arr</code> which pass an async truth test.<br><em>The callback for each <code>iterator</code> call only accepts a single argument of <code>true</code> or<br><code>false</code>; it does not accept an error argument first!</em> This is in-line with the<br>way node libraries work with truth tests like <code>fs.exists</code>. This operation is<br>performed in parallel, but the results array will be in the same order as the<br>original.</p><p><strong>Arguments</strong></p><ul>
<li><code>arr</code> - An array to iterate over.</li>
<li><code>iterator(item, callback)</code> - A truth test to apply to each item in <code>arr</code>.<br>The <code>iterator</code> is passed a <code>callback(truthValue)</code>, which must be called with a<br>boolean argument once it has completed.</li>
<li><code>callback(results)</code> - A callback which is called after all the <code>iterator</code><br>functions have finished.</li>
</ul><p><strong>Example</strong></p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;async.filter(['file1','file2','file3'], fs.exists, function(results){
    // results now equals an array of the existing files
});
&lt;/code&gt;&lt;/pre&gt;">async.filter([<span class="hljs-string">'file1'</span>,<span class="hljs-string">'file2'</span>,<span class="hljs-string">'file3'</span>], fs.exists, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(results)</span></span>{
    <span class="hljs-comment">// results now equals an array of the existing files</span>
});
</code></pre><hr class="section"><p><a name="selectSeries"><br></a><a name="filterSeries"></a></p><a name="filterSeries">
</a><h3 id="filterseries(arr,-iterator,-callback)"><a name="filterSeries"></a><a name="filterseries(arr,-iterator,-callback)" href="#filterseries(arr,-iterator,-callback)"></a>filterSeries(arr, iterator, callback)</h3><p><strong>Alias:</strong> <code>selectSeries</code></p><p>The same as <a href="#filter"><code>filter</code></a> only the <code>iterator</code> is applied to each item in <code>arr</code> in<br>series. The next <code>iterator</code> is only called once the current one has completed.<br>The results array will be in the same order as the original.</p><hr class="section"><p><a name="reject"></a></p><a name="reject">
</a><h3 id="reject(arr,-iterator,-callback)"><a name="reject"></a><a name="reject(arr,-iterator,-callback)" href="#reject(arr,-iterator,-callback)"></a>reject(arr, iterator, callback)</h3><p>The opposite of <a href="#filter"><code>filter</code></a>. Removes values that pass an <code>async</code> truth test.</p><hr class="section"><p><a name="rejectSeries"></a></p><a name="rejectSeries">
</a><h3 id="rejectseries(arr,-iterator,-callback)"><a name="rejectSeries"></a><a name="rejectseries(arr,-iterator,-callback)" href="#rejectseries(arr,-iterator,-callback)"></a>rejectSeries(arr, iterator, callback)</h3><p>The same as <a href="#reject"><code>reject</code></a>, only the <code>iterator</code> is applied to each item in <code>arr</code><br>in series.</p><hr class="section"><p><a name="reduce"></a></p><a name="reduce">
</a><h3 id="reduce(arr,-memo,-iterator,-callback)"><a name="reduce"></a><a name="reduce(arr,-memo,-iterator,-callback)" href="#reduce(arr,-memo,-iterator,-callback)"></a>reduce(arr, memo, iterator, callback)</h3><p><strong>Aliases:</strong> <code>inject</code>, <code>foldl</code></p><p>Reduces <code>arr</code> into a single value using an async <code>iterator</code> to return<br>each successive step. <code>memo</code> is the initial state of the reduction.<br>This function only operates in series. </p><p>For performance reasons, it may make sense to split a call to this function into<br>a parallel map, and then use the normal <code>Array.prototype.reduce</code> on the results.<br>This function is for situations where each step in the reduction needs to be async;<br>if you can get the data before reducing it, then it’s probably a good idea to do so.</p><p><strong>Arguments</strong></p><ul>
<li><code>arr</code> - An array to iterate over.</li>
<li><code>memo</code> - The initial state of the reduction.</li>
<li><code>iterator(memo, item, callback)</code> - A function applied to each item in the<br>array to produce the next step in the reduction. The <code>iterator</code> is passed a<br><code>callback(err, reduction)</code> which accepts an optional error as its first<br>argument, and the state of the reduction as the second. If an error is<br>passed to the callback, the reduction is stopped and the main <code>callback</code> is<br>immediately called with the error.</li>
<li><code>callback(err, result)</code> - A callback which is called after all the <code>iterator</code><br>functions have finished. Result is the reduced value.</li>
</ul><p><strong>Example</strong></p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;async.reduce([1,2,3], 0, function(memo, item, callback){
    // pointless async:
    process.nextTick(function(){
        callback(null, memo + item)
    });
}, function(err, result){
    // result is now equal to the last value of memo, which is 6
});
&lt;/code&gt;&lt;/pre&gt;">async.reduce([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-number">0</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(memo, item, callback)</span></span>{
    <span class="hljs-comment">// pointless async:</span>
    process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
        callback(<span class="hljs-literal">null</span>, memo + item)
    });
}, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, result)</span></span>{
    <span class="hljs-comment">// result is now equal to the last value of memo, which is 6</span>
});
</code></pre><hr class="section"><p><a name="reduceRight"></a></p><a name="reduceRight">
</a><h3 id="reduceright(arr,-memo,-iterator,-callback)"><a name="reduceRight"></a><a name="reduceright(arr,-memo,-iterator,-callback)" href="#reduceright(arr,-memo,-iterator,-callback)"></a>reduceRight(arr, memo, iterator, callback)</h3><p><strong>Alias:</strong> <code>foldr</code></p><p>Same as <a href="#reduce"><code>reduce</code></a>, only operates on <code>arr</code> in reverse order.</p><hr class="section"><p><a name="detect"></a></p><a name="detect">
</a><h3 id="detect(arr,-iterator,-callback)"><a name="detect"></a><a name="detect(arr,-iterator,-callback)" href="#detect(arr,-iterator,-callback)"></a>detect(arr, iterator, callback)</h3><p>Returns the first value in <code>arr</code> that passes an async truth test. The<br><code>iterator</code> is applied in parallel, meaning the first iterator to return <code>true</code> will<br>fire the detect <code>callback</code> with that result. That means the result might not be<br>the first item in the original <code>arr</code> (in terms of order) that passes the test.</p><p>If order within the original <code>arr</code> is important, then look at <a href="#detectSeries"><code>detectSeries</code></a>.</p><p><strong>Arguments</strong></p><ul>
<li><code>arr</code> - An array to iterate over.</li>
<li><code>iterator(item, callback)</code> - A truth test to apply to each item in <code>arr</code>.<br>The iterator is passed a <code>callback(truthValue)</code> which must be called with a<br>boolean argument once it has completed.</li>
<li><code>callback(result)</code> - A callback which is called as soon as any iterator returns<br><code>true</code>, or after all the <code>iterator</code> functions have finished. Result will be<br>the first item in the array that passes the truth test (iterator) or the<br>value <code>undefined</code> if none passed.</li>
</ul><p><strong>Example</strong></p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;async.detect(['file1','file2','file3'], fs.exists, function(result){
    // result now equals the first file in the list that exists
});
&lt;/code&gt;&lt;/pre&gt;">async.detect([<span class="hljs-string">'file1'</span>,<span class="hljs-string">'file2'</span>,<span class="hljs-string">'file3'</span>], fs.exists, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(result)</span></span>{
    <span class="hljs-comment">// result now equals the first file in the list that exists</span>
});
</code></pre><hr class="section"><p><a name="detectSeries"></a></p><a name="detectSeries">
</a><h3 id="detectseries(arr,-iterator,-callback)"><a name="detectSeries"></a><a name="detectseries(arr,-iterator,-callback)" href="#detectseries(arr,-iterator,-callback)"></a>detectSeries(arr, iterator, callback)</h3><p>The same as <a href="#detect"><code>detect</code></a>, only the <code>iterator</code> is applied to each item in <code>arr</code><br>in series. This means the result is always the first in the original <code>arr</code> (in<br>terms of array order) that passes the truth test.</p><hr class="section"><p><a name="sortBy"></a></p><a name="sortBy">
</a><h3 id="sortby(arr,-iterator,-callback)"><a name="sortBy"></a><a name="sortby(arr,-iterator,-callback)" href="#sortby(arr,-iterator,-callback)"></a>sortBy(arr, iterator, callback)</h3><p>Sorts a list by the results of running each <code>arr</code> value through an async <code>iterator</code>.</p><p><strong>Arguments</strong></p><ul>
<li><code>arr</code> - An array to iterate over.</li>
<li><code>iterator(item, callback)</code> - A function to apply to each item in <code>arr</code>.<br>The iterator is passed a <code>callback(err, sortValue)</code> which must be called once it<br>has completed with an error (which can be <code>null</code>) and a value to use as the sort<br>criteria.</li>
<li><code>callback(err, results)</code> - A callback which is called after all the <code>iterator</code><br>functions have finished, or an error occurs. Results is the items from<br>the original <code>arr</code> sorted by the values returned by the <code>iterator</code> calls.</li>
</ul><p><strong>Example</strong></p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;async.sortBy(['file1','file2','file3'], function(file, callback){
    fs.stat(file, function(err, stats){
        callback(err, stats.mtime);
    });
}, function(err, results){
    // results is now the original array of files sorted by
    // modified date
});
&lt;/code&gt;&lt;/pre&gt;">async.sortBy([<span class="hljs-string">'file1'</span>,<span class="hljs-string">'file2'</span>,<span class="hljs-string">'file3'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(file, callback)</span></span>{
    fs.stat(file, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, stats)</span></span>{
        callback(err, stats.mtime);
    });
}, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, results)</span></span>{
    <span class="hljs-comment">// results is now the original array of files sorted by</span>
    <span class="hljs-comment">// modified date</span>
});
</code></pre><p><strong>Sort Order</strong></p><p>By modifying the callback parameter the sorting order can be influenced:</p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;//ascending order
async.sortBy([1,9,3,5], function(x, callback){
    callback(err, x);
}, function(err,result){
    //result callback
} );

//descending order
async.sortBy([1,9,3,5], function(x, callback){
    callback(err, x*-1);    //&amp;lt;- x*-1 instead of x, turns the order around
}, function(err,result){
    //result callback
} );
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-comment">//ascending order</span>
async.sortBy([<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x, callback)</span></span>{
    callback(err, x);
}, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err,result)</span></span>{
    <span class="hljs-comment">//result callback</span>
} );

<span class="hljs-comment">//descending order</span>
async.sortBy([<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x, callback)</span></span>{
    callback(err, x*-<span class="hljs-number">1</span>);    <span class="hljs-comment">//&lt;- x*-1 instead of x, turns the order around</span>
}, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err,result)</span></span>{
    <span class="hljs-comment">//result callback</span>
} );
</code></pre><hr class="section"><p><a name="some"></a></p><a name="some">
</a><h3 id="some(arr,-iterator,-callback)"><a name="some"></a><a name="some(arr,-iterator,-callback)" href="#some(arr,-iterator,-callback)"></a>some(arr, iterator, callback)</h3><p><strong>Alias:</strong> <code>any</code></p><p>Returns <code>true</code> if at least one element in the <code>arr</code> satisfies an async test.<br><em>The callback for each iterator call only accepts a single argument of <code>true</code> or<br><code>false</code>; it does not accept an error argument first!</em> This is in-line with the<br>way node libraries work with truth tests like <code>fs.exists</code>. Once any iterator<br>call returns <code>true</code>, the main <code>callback</code> is immediately called.</p><p><strong>Arguments</strong></p><ul>
<li><code>arr</code> - An array to iterate over.</li>
<li><code>iterator(item, callback)</code> - A truth test to apply to each item in the array<br>in parallel. The iterator is passed a callback(truthValue) which must be<br>called with a boolean argument once it has completed.</li>
<li><code>callback(result)</code> - A callback which is called as soon as any iterator returns<br><code>true</code>, or after all the iterator functions have finished. Result will be<br>either <code>true</code> or <code>false</code> depending on the values of the async tests.</li>
</ul><p><strong>Example</strong></p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;async.some(['file1','file2','file3'], fs.exists, function(result){
    // if result is true then at least one of the files exists
});
&lt;/code&gt;&lt;/pre&gt;">async.some([<span class="hljs-string">'file1'</span>,<span class="hljs-string">'file2'</span>,<span class="hljs-string">'file3'</span>], fs.exists, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(result)</span></span>{
    <span class="hljs-comment">// if result is true then at least one of the files exists</span>
});
</code></pre><hr class="section"><p><a name="every"></a></p><a name="every">
</a><h3 id="every(arr,-iterator,-callback)"><a name="every"></a><a name="every(arr,-iterator,-callback)" href="#every(arr,-iterator,-callback)"></a>every(arr, iterator, callback)</h3><p><strong>Alias:</strong> <code>all</code></p><p>Returns <code>true</code> if every element in <code>arr</code> satisfies an async test.<br><em>The callback for each <code>iterator</code> call only accepts a single argument of <code>true</code> or<br><code>false</code>; it does not accept an error argument first!</em> This is in-line with the<br>way node libraries work with truth tests like <code>fs.exists</code>.</p><p><strong>Arguments</strong></p><ul>
<li><code>arr</code> - An array to iterate over.</li>
<li><code>iterator(item, callback)</code> - A truth test to apply to each item in the array<br>in parallel. The iterator is passed a callback(truthValue) which must be<br>called with a  boolean argument once it has completed.</li>
<li><code>callback(result)</code> - A callback which is called after all the <code>iterator</code><br>functions have finished. Result will be either <code>true</code> or <code>false</code> depending on<br>the values of the async tests.</li>
</ul><p><strong>Example</strong></p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;async.every(['file1','file2','file3'], fs.exists, function(result){
    // if result is true then every file exists
});
&lt;/code&gt;&lt;/pre&gt;">async.every([<span class="hljs-string">'file1'</span>,<span class="hljs-string">'file2'</span>,<span class="hljs-string">'file3'</span>], fs.exists, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(result)</span></span>{
    <span class="hljs-comment">// if result is true then every file exists</span>
});
</code></pre><hr class="section"><p><a name="concat"></a></p><a name="concat">
</a><h3 id="concat(arr,-iterator,-callback)"><a name="concat"></a><a name="concat(arr,-iterator,-callback)" href="#concat(arr,-iterator,-callback)"></a>concat(arr, iterator, callback)</h3><p>Applies <code>iterator</code> to each item in <code>arr</code>, concatenating the results. Returns the<br>concatenated list. The <code>iterator</code>s are called in parallel, and the results are<br>concatenated as they return. There is no guarantee that the results array will<br>be returned in the original order of <code>arr</code> passed to the <code>iterator</code> function.</p><p><strong>Arguments</strong></p><ul>
<li><code>arr</code> - An array to iterate over.</li>
<li><code>iterator(item, callback)</code> - A function to apply to each item in <code>arr</code>.<br>The iterator is passed a <code>callback(err, results)</code> which must be called once it<br>has completed with an error (which can be <code>null</code>) and an array of results.</li>
<li><code>callback(err, results)</code> - A callback which is called after all the <code>iterator</code><br>functions have finished, or an error occurs. Results is an array containing<br>the concatenated results of the <code>iterator</code> function.</li>
</ul><p><strong>Example</strong></p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files){
    // files is now a list of filenames that exist in the 3 directories
});
&lt;/code&gt;&lt;/pre&gt;">async.concat([<span class="hljs-string">'dir1'</span>,<span class="hljs-string">'dir2'</span>,<span class="hljs-string">'dir3'</span>], fs.readdir, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, files)</span></span>{
    <span class="hljs-comment">// files is now a list of filenames that exist in the 3 directories</span>
});
</code></pre><hr class="section"><p><a name="concatSeries"></a></p><a name="concatSeries">
</a><h3 id="concatseries(arr,-iterator,-callback)"><a name="concatSeries"></a><a name="concatseries(arr,-iterator,-callback)" href="#concatseries(arr,-iterator,-callback)"></a>concatSeries(arr, iterator, callback)</h3><p>Same as <a href="#concat"><code>concat</code></a>, but executes in series instead of parallel.</p><h2 id="control-flow"><a name="control-flow" href="#control-flow"></a>Control Flow</h2><p><a name="series"></a></p><a name="series">
</a><h3 id="series(tasks,-[callback])"><a name="series"></a><a name="series(tasks,-[callback])" href="#series(tasks,-[callback])"></a>series(tasks, [callback])</h3><p>Run the functions in the <code>tasks</code> array in series, each one running once the previous<br>function has completed. If any functions in the series pass an error to its<br>callback, no more functions are run, and <code>callback</code> is immediately called with the value of the error.<br>Otherwise, <code>callback</code> receives an array of results when <code>tasks</code> have completed.</p><p>It is also possible to use an object instead of an array. Each property will be<br>run as a function, and the results will be passed to the final <code>callback</code> as an object<br>instead of an array. This can be a more readable way of handling results from<br><a href="#series"><code>series</code></a>.</p><p><strong>Note</strong> that while many implementations preserve the order of object properties, the<br><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-8.6">ECMAScript Language Specifcation</a><br>explicitly states that</p><blockquote>
<p>The mechanics and order of enumerating the properties is not specified.</p>
</blockquote><p>So if you rely on the order in which your series of functions are executed, and want<br>this to work on all platforms, consider using an array. </p><p><strong>Arguments</strong></p><ul>
<li><code>tasks</code> - An array or object containing functions to run, each function is passed<br>a <code>callback(err, result)</code> it must call on completion with an error <code>err</code> (which can<br>be <code>null</code>) and an optional <code>result</code> value.</li>
<li><code>callback(err, results)</code> - An optional callback to run once all the functions<br>have completed. This function gets a results array (or object) containing all<br>the result arguments passed to the <code>task</code> callbacks.</li>
</ul><p><strong>Example</strong></p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;async.series([
    function(callback){
        // do some stuff ...
        callback(null, 'one');
    },
    function(callback){
        // do some more stuff ...
        callback(null, 'two');
    }
],
// optional callback
function(err, results){
    // results is now equal to ['one', 'two']
});


// an example using an object instead of an array
async.series({
    one: function(callback){
        setTimeout(function(){
            callback(null, 1);
        }, 200);
    },
    two: function(callback){
        setTimeout(function(){
            callback(null, 2);
        }, 100);
    }
},
function(err, results) {
    // results is now equal to: {one: 1, two: 2}
});
&lt;/code&gt;&lt;/pre&gt;">async.series([
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callback)</span></span>{
        <span class="hljs-comment">// do some stuff ...</span>
        callback(<span class="hljs-literal">null</span>, <span class="hljs-string">'one'</span>);
    },
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callback)</span></span>{
        <span class="hljs-comment">// do some more stuff ...</span>
        callback(<span class="hljs-literal">null</span>, <span class="hljs-string">'two'</span>);
    }
],
<span class="hljs-comment">// optional callback</span>
<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, results)</span></span>{
    <span class="hljs-comment">// results is now equal to ['one', 'two']</span>
});


<span class="hljs-comment">// an example using an object instead of an array</span>
async.series({
    one: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callback)</span></span>{
        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
            callback(<span class="hljs-literal">null</span>, <span class="hljs-number">1</span>);
        }, <span class="hljs-number">200</span>);
    },
    two: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callback)</span></span>{
        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
            callback(<span class="hljs-literal">null</span>, <span class="hljs-number">2</span>);
        }, <span class="hljs-number">100</span>);
    }
},
<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, results)</span> </span>{
    <span class="hljs-comment">// results is now equal to: {one: 1, two: 2}</span>
});
</code></pre><hr class="section"><p><a name="parallel"></a></p><a name="parallel">
</a><h3 id="parallel(tasks,-[callback])"><a name="parallel"></a><a name="parallel(tasks,-[callback])" href="#parallel(tasks,-[callback])"></a>parallel(tasks, [callback])</h3><p>Run the <code>tasks</code> array of functions in parallel, without waiting until the previous<br>function has completed. If any of the functions pass an error to its<br>callback, the main <code>callback</code> is immediately called with the value of the error.<br>Once the <code>tasks</code> have completed, the results are passed to the final <code>callback</code> as an<br>array.</p><p>It is also possible to use an object instead of an array. Each property will be<br>run as a function and the results will be passed to the final <code>callback</code> as an object<br>instead of an array. This can be a more readable way of handling results from<br><a href="#parallel"><code>parallel</code></a>.</p><p><strong>Arguments</strong></p><ul>
<li><code>tasks</code> - An array or object containing functions to run. Each function is passed<br>a <code>callback(err, result)</code> which it must call on completion with an error <code>err</code><br>(which can be <code>null</code>) and an optional <code>result</code> value.</li>
<li><code>callback(err, results)</code> - An optional callback to run once all the functions<br>have completed. This function gets a results array (or object) containing all<br>the result arguments passed to the task callbacks.</li>
</ul><p><strong>Example</strong></p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;async.parallel([
    function(callback){
        setTimeout(function(){
            callback(null, 'one');
        }, 200);
    },
    function(callback){
        setTimeout(function(){
            callback(null, 'two');
        }, 100);
    }
],
// optional callback
function(err, results){
    // the results array will equal ['one','two'] even though
    // the second function had a shorter timeout.
});


// an example using an object instead of an array
async.parallel({
    one: function(callback){
        setTimeout(function(){
            callback(null, 1);
        }, 200);
    },
    two: function(callback){
        setTimeout(function(){
            callback(null, 2);
        }, 100);
    }
},
function(err, results) {
    // results is now equals to: {one: 1, two: 2}
});
&lt;/code&gt;&lt;/pre&gt;">async.parallel([
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callback)</span></span>{
        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
            callback(<span class="hljs-literal">null</span>, <span class="hljs-string">'one'</span>);
        }, <span class="hljs-number">200</span>);
    },
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callback)</span></span>{
        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
            callback(<span class="hljs-literal">null</span>, <span class="hljs-string">'two'</span>);
        }, <span class="hljs-number">100</span>);
    }
],
<span class="hljs-comment">// optional callback</span>
<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, results)</span></span>{
    <span class="hljs-comment">// the results array will equal ['one','two'] even though</span>
    <span class="hljs-comment">// the second function had a shorter timeout.</span>
});


<span class="hljs-comment">// an example using an object instead of an array</span>
async.parallel({
    one: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callback)</span></span>{
        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
            callback(<span class="hljs-literal">null</span>, <span class="hljs-number">1</span>);
        }, <span class="hljs-number">200</span>);
    },
    two: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callback)</span></span>{
        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
            callback(<span class="hljs-literal">null</span>, <span class="hljs-number">2</span>);
        }, <span class="hljs-number">100</span>);
    }
},
<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, results)</span> </span>{
    <span class="hljs-comment">// results is now equals to: {one: 1, two: 2}</span>
});
</code></pre><hr class="section"><p><a name="parallelLimit"></a></p><a name="parallelLimit">
</a><h3 id="parallellimit(tasks,-limit,-[callback])"><a name="parallelLimit"></a><a name="parallellimit(tasks,-limit,-[callback])" href="#parallellimit(tasks,-limit,-[callback])"></a>parallelLimit(tasks, limit, [callback])</h3><p>The same as <a href="#parallel"><code>parallel</code></a>, only <code>tasks</code> are executed in parallel<br>with a maximum of <code>limit</code> tasks executing at any time.</p><p>Note that the <code>tasks</code> are not executed in batches, so there is no guarantee that<br>the first <code>limit</code> tasks will complete before any others are started.</p><p><strong>Arguments</strong></p><ul>
<li><code>tasks</code> - An array or object containing functions to run, each function is passed<br>a <code>callback(err, result)</code> it must call on completion with an error <code>err</code> (which can<br>be <code>null</code>) and an optional <code>result</code> value.</li>
<li><code>limit</code> - The maximum number of <code>tasks</code> to run at any time.</li>
<li><code>callback(err, results)</code> - An optional callback to run once all the functions<br>have completed. This function gets a results array (or object) containing all<br>the result arguments passed to the <code>task</code> callbacks.</li>
</ul><hr class="section"><p><a name="whilst"></a></p><a name="whilst">
</a><h3 id="whilst(test,-fn,-callback)"><a name="whilst"></a><a name="whilst(test,-fn,-callback)" href="#whilst(test,-fn,-callback)"></a>whilst(test, fn, callback)</h3><p>Repeatedly call <code>fn</code>, while <code>test</code> returns <code>true</code>. Calls <code>callback</code> when stopped,<br>or an error occurs.</p><p><strong>Arguments</strong></p><ul>
<li><code>test()</code> - synchronous truth test to perform before each execution of <code>fn</code>.</li>
<li><code>fn(callback)</code> - A function which is called each time <code>test</code> passes. The function is<br>passed a <code>callback(err)</code>, which must be called once it has completed with an<br>optional <code>err</code> argument.</li>
<li><code>callback(err)</code> - A callback which is called after the test fails and repeated<br>execution of <code>fn</code> has stopped.</li>
</ul><p><strong>Example</strong></p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;var count = 0;

async.whilst(
    function () { return count &amp;lt; 5; },
    function (callback) {
        count++;
        setTimeout(callback, 1000);
    },
    function (err) {
        // 5 seconds have passed
    }
);
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;

async.whilst(
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> count &lt; <span class="hljs-number">5</span>; },
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(callback)</span> </span>{
        count++;
        setTimeout(callback, <span class="hljs-number">1000</span>);
    },
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> </span>{
        <span class="hljs-comment">// 5 seconds have passed</span>
    }
);
</code></pre><hr class="section"><p><a name="doWhilst"></a></p><a name="doWhilst">
</a><h3 id="dowhilst(fn,-test,-callback)"><a name="doWhilst"></a><a name="dowhilst(fn,-test,-callback)" href="#dowhilst(fn,-test,-callback)"></a>doWhilst(fn, test, callback)</h3><p>The post-check version of <a href="#whilst"><code>whilst</code></a>. To reflect the difference in<br>the order of operations, the arguments <code>test</code> and <code>fn</code> are switched. </p><p><code>doWhilst</code> is to <code>whilst</code> as <code>do while</code> is to <code>while</code> in plain JavaScript.</p><hr class="section"><p><a name="until"></a></p><a name="until">
</a><h3 id="until(test,-fn,-callback)"><a name="until"></a><a name="until(test,-fn,-callback)" href="#until(test,-fn,-callback)"></a>until(test, fn, callback)</h3><p>Repeatedly call <code>fn</code> until <code>test</code> returns <code>true</code>. Calls <code>callback</code> when stopped,<br>or an error occurs.</p><p>The inverse of <a href="#whilst"><code>whilst</code></a>.</p><hr class="section"><p><a name="doUntil"></a></p><a name="doUntil">
</a><h3 id="dountil(fn,-test,-callback)"><a name="doUntil"></a><a name="dountil(fn,-test,-callback)" href="#dountil(fn,-test,-callback)"></a>doUntil(fn, test, callback)</h3><p>Like <a href="#doWhilst"><code>doWhilst</code></a>, except the <code>test</code> is inverted. Note the argument ordering differs from <code>until</code>.</p><hr class="section"><p><a name="forever"></a></p><a name="forever">
</a><h3 id="forever(fn,-errback)"><a name="forever"></a><a name="forever(fn,-errback)" href="#forever(fn,-errback)"></a>forever(fn, errback)</h3><p>Calls the asynchronous function <code>fn</code> with a callback parameter that allows it to<br>call itself again, in series, indefinitely.</p><p>If an error is passed to the callback then <code>errback</code> is called with the<br>error, and execution stops, otherwise it will never be called.</p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;async.forever(
    function(next) {
        // next is suitable for passing to things that need a callback(err [, whatever]);
        // it will result in this function being called again.
    },
    function(err) {
        // if next is called with a value in its first parameter, it will appear
        // in here as 'err', and execution will stop.
    }
);
&lt;/code&gt;&lt;/pre&gt;">async.forever(
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(next)</span> </span>{
        <span class="hljs-comment">// next is suitable for passing to things that need a callback(err [, whatever]);</span>
        <span class="hljs-comment">// it will result in this function being called again.</span>
    },
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err)</span> </span>{
        <span class="hljs-comment">// if next is called with a value in its first parameter, it will appear</span>
        <span class="hljs-comment">// in here as 'err', and execution will stop.</span>
    }
);
</code></pre><hr class="section"><p><a name="waterfall"></a></p><a name="waterfall">
</a><h3 id="waterfall(tasks,-[callback])"><a name="waterfall"></a><a name="waterfall(tasks,-[callback])" href="#waterfall(tasks,-[callback])"></a>waterfall(tasks, [callback])</h3><p>Runs the <code>tasks</code> array of functions in series, each passing their results to the next in<br>the array. However, if any of the <code>tasks</code> pass an error to their own callback, the<br>next function is not executed, and the main <code>callback</code> is immediately called with<br>the error.</p><p><strong>Arguments</strong></p><ul>
<li><code>tasks</code> - An array of functions to run, each function is passed a<br><code>callback(err, result1, result2, ...)</code> it must call on completion. The first<br>argument is an error (which can be <code>null</code>) and any further arguments will be<br>passed as arguments in order to the next task.</li>
<li><code>callback(err, [results])</code> - An optional callback to run once all the functions<br>have completed. This will be passed the results of the last task’s callback.</li>
</ul><p><strong>Example</strong></p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;async.waterfall([
    function(callback){
        callback(null, 'one', 'two');
    },
    function(arg1, arg2, callback){
      // arg1 now equals 'one' and arg2 now equals 'two'
        callback(null, 'three');
    },
    function(arg1, callback){
        // arg1 now equals 'three'
        callback(null, 'done');
    }
], function (err, result) {
   // result now equals 'done'    
});
&lt;/code&gt;&lt;/pre&gt;">async.waterfall([
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callback)</span></span>{
        callback(<span class="hljs-literal">null</span>, <span class="hljs-string">'one'</span>, <span class="hljs-string">'two'</span>);
    },
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arg1, arg2, callback)</span></span>{
      <span class="hljs-comment">// arg1 now equals 'one' and arg2 now equals 'two'</span>
        callback(<span class="hljs-literal">null</span>, <span class="hljs-string">'three'</span>);
    },
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arg1, callback)</span></span>{
        <span class="hljs-comment">// arg1 now equals 'three'</span>
        callback(<span class="hljs-literal">null</span>, <span class="hljs-string">'done'</span>);
    }
], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err, result)</span> </span>{
   <span class="hljs-comment">// result now equals 'done'    </span>
});
</code></pre><hr class="section"><p><a name="compose"></a></p><a name="compose">
</a><h3 id="compose(fn1,-fn2...)"><a name="compose"></a><a name="compose(fn1,-fn2...)" href="#compose(fn1,-fn2...)"></a>compose(fn1, fn2…)</h3><p>Creates a function which is a composition of the passed asynchronous<br>functions. Each function consumes the return value of the function that<br>follows. Composing functions <code>f()</code>, <code>g()</code>, and <code>h()</code> would produce the result of<br><code>f(g(h()))</code>, only this version uses callbacks to obtain the return values.</p><p>Each function is executed with the <code>this</code> binding of the composed function.</p><p><strong>Arguments</strong></p><ul>
<li><code>functions...</code> - the asynchronous functions to compose</li>
</ul><p><strong>Example</strong></p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;function add1(n, callback) {
    setTimeout(function () {
        callback(null, n + 1);
    }, 10);
}

function mul3(n, callback) {
    setTimeout(function () {
        callback(null, n * 3);
    }, 10);
}

var add1mul3 = async.compose(mul3, add1);

add1mul3(4, function (err, result) {
   // result now equals 15
});
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add1</span><span class="hljs-params">(n, callback)</span> </span>{
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        callback(<span class="hljs-literal">null</span>, n + <span class="hljs-number">1</span>);
    }, <span class="hljs-number">10</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mul3</span><span class="hljs-params">(n, callback)</span> </span>{
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        callback(<span class="hljs-literal">null</span>, n * <span class="hljs-number">3</span>);
    }, <span class="hljs-number">10</span>);
}

<span class="hljs-keyword">var</span> add1mul3 = async.compose(mul3, add1);

add1mul3(<span class="hljs-number">4</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err, result)</span> </span>{
   <span class="hljs-comment">// result now equals 15</span>
});
</code></pre><hr class="section"><p><a name="seq"></a></p><a name="seq">
</a><h3 id="seq(fn1,-fn2...)"><a name="seq"></a><a name="seq(fn1,-fn2...)" href="#seq(fn1,-fn2...)"></a>seq(fn1, fn2…)</h3><p>Version of the compose function that is more natural to read.<br>Each following function consumes the return value of the latter function. </p><p>Each function is executed with the <code>this</code> binding of the composed function.</p><p><strong>Arguments</strong></p><ul>
<li>functions… - the asynchronous functions to compose</li>
</ul><p><strong>Example</strong></p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;// Requires lodash (or underscore), express3 and dresende's orm2.
// Part of an app, that fetches cats of the logged user.
// This example uses `seq` function to avoid overnesting and error 
// handling clutter.
app.get('/cats', function(request, response) {
  function handleError(err, data, callback) {
    if (err) {
      console.error(err);
      response.json({ status: 'error', message: err.message });
    }
    else {
      callback(data);
    }
  }
  var User = request.models.User;
  async.seq(
    _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))
    handleError,
    function(user, fn) {
      user.getCats(fn);      // 'getCats' has signature (callback(err, data))
    },
    handleError,
    function(cats) {
      response.json({ status: 'ok', message: 'Cats found', data: cats });
    }
  )(req.session.user_id);
  }
});
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-comment">// Requires lodash (or underscore), express3 and dresende's orm2.</span>
<span class="hljs-comment">// Part of an app, that fetches cats of the logged user.</span>
<span class="hljs-comment">// This example uses `seq` function to avoid overnesting and error </span>
<span class="hljs-comment">// handling clutter.</span>
app.get(<span class="hljs-string">'/cats'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(request, response)</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleError</span><span class="hljs-params">(err, data, callback)</span> </span>{
    <span class="hljs-keyword">if</span> (err) {
      <span class="hljs-built_in">console</span>.error(err);
      response.json({ status: <span class="hljs-string">'error'</span>, message: err.message });
    }
    <span class="hljs-keyword">else</span> {
      callback(data);
    }
  }
  <span class="hljs-keyword">var</span> User = request.models.User;
  async.seq(
    _.bind(User.get, User),  <span class="hljs-comment">// 'User.get' has signature (id, callback(err, data))</span>
    handleError,
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(user, fn)</span> </span>{
      user.getCats(fn);      <span class="hljs-comment">// 'getCats' has signature (callback(err, data))</span>
    },
    handleError,
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(cats)</span> </span>{
      response.json({ status: <span class="hljs-string">'ok'</span>, message: <span class="hljs-string">'Cats found'</span>, data: cats });
    }
  )(req.session.user_id);
  }
});
</code></pre><hr class="section"><p><a name="applyEach"></a></p><a name="applyEach">
</a><h3 id="applyeach(fns,-args...,-callback)"><a name="applyEach"></a><a name="applyeach(fns,-args...,-callback)" href="#applyeach(fns,-args...,-callback)"></a>applyEach(fns, args…, callback)</h3><p>Applies the provided arguments to each function in the array, calling<br><code>callback</code> after all functions have completed. If you only provide the first<br>argument, then it will return a function which lets you pass in the<br>arguments as if it were a single function call.</p><p><strong>Arguments</strong></p><ul>
<li><code>fns</code> - the asynchronous functions to all call with the same arguments</li>
<li><code>args...</code> - any number of separate arguments to pass to the function</li>
<li><code>callback</code> - the final argument should be the callback, called when all<br>functions have completed processing</li>
</ul><p><strong>Example</strong></p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;async.applyEach([enableSearch, updateSchema], 'bucket', callback);

// partial application example:
async.each(
    buckets,
    async.applyEach([enableSearch, updateSchema]),
    callback
);
&lt;/code&gt;&lt;/pre&gt;">async.applyEach([enableSearch, updateSchema], <span class="hljs-string">'bucket'</span>, callback);

<span class="hljs-comment">// partial application example:</span>
async.each(
    buckets,
    async.applyEach([enableSearch, updateSchema]),
    callback
);
</code></pre><hr class="section"><p><a name="applyEachSeries"></a></p><a name="applyEachSeries">
</a><h3 id="applyeachseries(arr,-iterator,-callback)"><a name="applyEachSeries"></a><a name="applyeachseries(arr,-iterator,-callback)" href="#applyeachseries(arr,-iterator,-callback)"></a>applyEachSeries(arr, iterator, callback)</h3><p>The same as <a href="#applyEach"><code>applyEach</code></a> only the functions are applied in series.</p><hr class="section"><p><a name="queue"></a></p><a name="queue">
</a><h3 id="queue(worker,-concurrency)"><a name="queue"></a><a name="queue(worker,-concurrency)" href="#queue(worker,-concurrency)"></a>queue(worker, concurrency)</h3><p>Creates a <code>queue</code> object with the specified <code>concurrency</code>. Tasks added to the<br><code>queue</code> are processed in parallel (up to the <code>concurrency</code> limit). If all<br><code>worker</code>s are in progress, the task is queued until one becomes available.<br>Once a <code>worker</code> completes a <code>task</code>, that <code>task</code>‘s callback is called.</p><p><strong>Arguments</strong></p><ul>
<li><code>worker(task, callback)</code> - An asynchronous function for processing a queued<br>task, which must call its <code>callback(err)</code> argument when finished, with an<br>optional <code>error</code> as an argument.</li>
<li><code>concurrency</code> - An <code>integer</code> for determining how many <code>worker</code> functions should be<br>run in parallel.</li>
</ul><p><strong>Queue objects</strong></p><p>The <code>queue</code> object returned by this function has the following properties and<br>methods:</p><ul>
<li><code>length()</code> - a function returning the number of items waiting to be processed.</li>
<li><code>started</code> - a function returning whether or not any items have been pushed and processed by the queue</li>
<li><code>running()</code> - a function returning the number of items currently being processed.</li>
<li><code>idle()</code> - a function returning false if there are items waiting or being processed, or true if not.</li>
<li><code>concurrency</code> - an integer for determining how many <code>worker</code> functions should be<br>run in parallel. This property can be changed after a <code>queue</code> is created to<br>alter the concurrency on-the-fly.</li>
<li><code>push(task, [callback])</code> - add a new task to the <code>queue</code>. Calls <code>callback</code> once<br>the <code>worker</code> has finished processing the task. Instead of a single task, a <code>tasks</code> array<br>can be submitted. The respective callback is used for every task in the list.</li>
<li><code>unshift(task, [callback])</code> - add a new task to the front of the <code>queue</code>.</li>
<li><code>saturated</code> - a callback that is called when the <code>queue</code> length hits the <code>concurrency</code> limit,<br> and further tasks will be queued.</li>
<li><code>empty</code> - a callback that is called when the last item from the <code>queue</code> is given to a <code>worker</code>.</li>
<li><code>drain</code> - a callback that is called when the last item from the <code>queue</code> has returned from the <code>worker</code>.</li>
<li><code>paused</code> - a boolean for determining whether the queue is in a paused state</li>
<li><code>pause()</code> - a function that pauses the processing of tasks until <code>resume()</code> is called.</li>
<li><code>resume()</code> - a function that resumes the processing of queued tasks when the queue is paused.</li>
<li><code>kill()</code> - a function that empties remaining tasks from the queue forcing it to go idle.</li>
</ul><p><strong>Example</strong></p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;// create a queue object with concurrency 2

var q = async.queue(function (task, callback) {
    console.log('hello ' + task.name);
    callback();
}, 2);


// assign a callback
q.drain = function() {
    console.log('all items have been processed');
}

// add some items to the queue

q.push({name: 'foo'}, function (err) {
    console.log('finished processing foo');
});
q.push({name: 'bar'}, function (err) {
    console.log('finished processing bar');
});

// add some items to the queue (batch-wise)

q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function (err) {
    console.log('finished processing bar');
});

// add some items to the front of the queue

q.unshift({name: 'bar'}, function (err) {
    console.log('finished processing bar');
});
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-comment">// create a queue object with concurrency 2</span>

<span class="hljs-keyword">var</span> q = async.queue(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(task, callback)</span> </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hello '</span> + task.name);
    callback();
}, <span class="hljs-number">2</span>);


<span class="hljs-comment">// assign a callback</span>
q.drain = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'all items have been processed'</span>);
}

<span class="hljs-comment">// add some items to the queue</span>

q.push({name: <span class="hljs-string">'foo'</span>}, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finished processing foo'</span>);
});
q.push({name: <span class="hljs-string">'bar'</span>}, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finished processing bar'</span>);
});

<span class="hljs-comment">// add some items to the queue (batch-wise)</span>

q.push([{name: <span class="hljs-string">'baz'</span>},{name: <span class="hljs-string">'bay'</span>},{name: <span class="hljs-string">'bax'</span>}], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finished processing bar'</span>);
});

<span class="hljs-comment">// add some items to the front of the queue</span>

q.unshift({name: <span class="hljs-string">'bar'</span>}, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finished processing bar'</span>);
});
</code></pre><hr class="section"><p><a name="priorityQueue"></a></p><a name="priorityQueue">
</a><h3 id="priorityqueue(worker,-concurrency)"><a name="priorityQueue"></a><a name="priorityqueue(worker,-concurrency)" href="#priorityqueue(worker,-concurrency)"></a>priorityQueue(worker, concurrency)</h3><p>The same as <a href="#queue"><code>queue</code></a> only tasks are assigned a priority and completed in ascending priority order. There are two differences between <code>queue</code> and <code>priorityQueue</code> objects:</p><ul>
<li><code>push(task, priority, [callback])</code> - <code>priority</code> should be a number. If an array of<br><code>tasks</code> is given, all tasks will be assigned the same priority.</li>
<li>The <code>unshift</code> method was removed.</li>
</ul><hr class="section"><p><a name="cargo"></a></p><a name="cargo">
</a><h3 id="cargo(worker,-[payload])"><a name="cargo"></a><a name="cargo(worker,-[payload])" href="#cargo(worker,-[payload])"></a>cargo(worker, [payload])</h3><p>Creates a <code>cargo</code> object with the specified payload. Tasks added to the<br>cargo will be processed altogether (up to the <code>payload</code> limit). If the<br><code>worker</code> is in progress, the task is queued until it becomes available. Once<br>the <code>worker</code> has completed some tasks, each callback of those tasks is called.<br>Check out <a href="https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966">this animation</a> for how <code>cargo</code> and <code>queue</code> work.</p><p>While <a href="#queue">queue</a> passes only one task to one of a group of workers<br>at a time, cargo passes an array of tasks to a single worker, repeating<br>when the worker is finished.</p><p><strong>Arguments</strong></p><ul>
<li><code>worker(tasks, callback)</code> - An asynchronous function for processing an array of<br>queued tasks, which must call its <code>callback(err)</code> argument when finished, with<br>an optional <code>err</code> argument.</li>
<li><code>payload</code> - An optional <code>integer</code> for determining how many tasks should be<br>processed per round; if omitted, the default is unlimited.</li>
</ul><p><strong>Cargo objects</strong></p><p>The <code>cargo</code> object returned by this function has the following properties and<br>methods:</p><ul>
<li><code>length()</code> - A function returning the number of items waiting to be processed.</li>
<li><code>payload</code> - An <code>integer</code> for determining how many tasks should be<br>process per round. This property can be changed after a <code>cargo</code> is created to<br>alter the payload on-the-fly.</li>
<li><code>push(task, [callback])</code> - Adds <code>task</code> to the <code>queue</code>. The callback is called<br>once the <code>worker</code> has finished processing the task. Instead of a single task, an array of <code>tasks</code><br>can be submitted. The respective callback is used for every task in the list.</li>
<li><code>saturated</code> - A callback that is called when the <code>queue.length()</code> hits the concurrency and further tasks will be queued.</li>
<li><code>empty</code> - A callback that is called when the last item from the <code>queue</code> is given to a <code>worker</code>.</li>
<li><code>drain</code> - A callback that is called when the last item from the <code>queue</code> has returned from the <code>worker</code>.</li>
</ul><p><strong>Example</strong></p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;// create a cargo object with payload 2

var cargo = async.cargo(function (tasks, callback) {
    for(var i=0; i&amp;lt;tasks.length; i++){
      console.log('hello ' + tasks[i].name);
    }
    callback();
}, 2);


// add some items

cargo.push({name: 'foo'}, function (err) {
    console.log('finished processing foo');
});
cargo.push({name: 'bar'}, function (err) {
    console.log('finished processing bar');
});
cargo.push({name: 'baz'}, function (err) {
    console.log('finished processing baz');
});
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-comment">// create a cargo object with payload 2</span>

<span class="hljs-keyword">var</span> cargo = async.cargo(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(tasks, callback)</span> </span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;tasks.length; i++){
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hello '</span> + tasks[i].name);
    }
    callback();
}, <span class="hljs-number">2</span>);


<span class="hljs-comment">// add some items</span>

cargo.push({name: <span class="hljs-string">'foo'</span>}, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finished processing foo'</span>);
});
cargo.push({name: <span class="hljs-string">'bar'</span>}, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finished processing bar'</span>);
});
cargo.push({name: <span class="hljs-string">'baz'</span>}, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finished processing baz'</span>);
});
</code></pre><hr class="section"><p><a name="auto"></a></p><a name="auto">
</a><h3 id="auto(tasks,-[callback])"><a name="auto"></a><a name="auto(tasks,-[callback])" href="#auto(tasks,-[callback])"></a>auto(tasks, [callback])</h3><p>Determines the best order for running the functions in <code>tasks</code>, based on their<br>requirements. Each function can optionally depend on other functions being completed<br>first, and each function is run as soon as its requirements are satisfied. </p><p>If any of the functions pass an error to their callback, it will not<br>complete (so any other functions depending on it will not run), and the main<br><code>callback</code> is immediately called with the error. Functions also receive an<br>object containing the results of functions which have completed so far.</p><p>Note, all functions are called with a <code>results</code> object as a second argument,<br>so it is unsafe to pass functions in the <code>tasks</code> object which cannot handle the<br>extra argument. </p><p>For example, this snippet of code:</p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;async.auto({
  readData: async.apply(fs.readFile, 'data.txt', 'utf-8')
}, callback);
&lt;/code&gt;&lt;/pre&gt;">async.auto({
  readData: async.apply(fs.readFile, <span class="hljs-string">'data.txt'</span>, <span class="hljs-string">'utf-8'</span>)
}, callback);
</code></pre><p>will have the effect of calling <code>readFile</code> with the results object as the last<br>argument, which will fail:</p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;fs.readFile('data.txt', 'utf-8', cb, {});
&lt;/code&gt;&lt;/pre&gt;">fs.readFile(<span class="hljs-string">'data.txt'</span>, <span class="hljs-string">'utf-8'</span>, cb, {});
</code></pre><p>Instead, wrap the call to <code>readFile</code> in a function which does not forward the<br><code>results</code> object:</p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;async.auto({
  readData: function(cb, results){
    fs.readFile('data.txt', 'utf-8', cb);
  }
}, callback);
&lt;/code&gt;&lt;/pre&gt;">async.auto({
  readData: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(cb, results)</span></span>{
    fs.readFile(<span class="hljs-string">'data.txt'</span>, <span class="hljs-string">'utf-8'</span>, cb);
  }
}, callback);
</code></pre><p><strong>Arguments</strong></p><ul>
<li><code>tasks</code> - An object. Each of its properties is either a function or an array of<br>requirements, with the function itself the last item in the array. The object’s key<br>of a property serves as the name of the task defined by that property,<br>i.e. can be used when specifying requirements for other tasks.<br>The function receives two arguments: (1) a <code>callback(err, result)</code> which must be<br>called when finished, passing an <code>error</code> (which can be <code>null</code>) and the result of<br>the function’s execution, and (2) a <code>results</code> object, containing the results of<br>the previously executed functions.</li>
<li><code>callback(err, results)</code> - An optional callback which is called when all the<br>tasks have been completed. It receives the <code>err</code> argument if any <code>tasks</code><br>pass an error to their callback. Results are always returned; however, if<br>an error occurs, no further <code>tasks</code> will be performed, and the results<br>object will only contain partial results.</li>
</ul><p><strong>Example</strong></p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;async.auto({
    get_data: function(callback){
        console.log('in get_data');
        // async code to get some data
        callback(null, 'data', 'converted to array');
    },
    make_folder: function(callback){
        console.log('in make_folder');
        // async code to create a directory to store a file in
        // this is run at the same time as getting the data
        callback(null, 'folder');
    },
    write_file: ['get_data', 'make_folder', function(callback, results){
        console.log('in write_file', JSON.stringify(results));
        // once there is some data and the directory exists,
        // write the data to a file in the directory
        callback(null, 'filename');
    }],
    email_link: ['write_file', function(callback, results){
        console.log('in email_link', JSON.stringify(results));
        // once the file is written let's email a link to it...
        // results.write_file contains the filename returned by write_file.
        callback(null, {'file':results.write_file, 'email':'user@example.com'});
    }]
}, function(err, results) {
    console.log('err = ', err);
    console.log('results = ', results);
});
&lt;/code&gt;&lt;/pre&gt;">async.auto({
    get_data: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callback)</span></span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'in get_data'</span>);
        <span class="hljs-comment">// async code to get some data</span>
        callback(<span class="hljs-literal">null</span>, <span class="hljs-string">'data'</span>, <span class="hljs-string">'converted to array'</span>);
    },
    make_folder: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callback)</span></span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'in make_folder'</span>);
        <span class="hljs-comment">// async code to create a directory to store a file in</span>
        <span class="hljs-comment">// this is run at the same time as getting the data</span>
        callback(<span class="hljs-literal">null</span>, <span class="hljs-string">'folder'</span>);
    },
    write_file: [<span class="hljs-string">'get_data'</span>, <span class="hljs-string">'make_folder'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callback, results)</span></span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'in write_file'</span>, <span class="hljs-built_in">JSON</span>.stringify(results));
        <span class="hljs-comment">// once there is some data and the directory exists,</span>
        <span class="hljs-comment">// write the data to a file in the directory</span>
        callback(<span class="hljs-literal">null</span>, <span class="hljs-string">'filename'</span>);
    }],
    email_link: [<span class="hljs-string">'write_file'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callback, results)</span></span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'in email_link'</span>, <span class="hljs-built_in">JSON</span>.stringify(results));
        <span class="hljs-comment">// once the file is written let's email a link to it...</span>
        <span class="hljs-comment">// results.write_file contains the filename returned by write_file.</span>
        callback(<span class="hljs-literal">null</span>, {<span class="hljs-string">'file'</span>:results.write_file, <span class="hljs-string">'email'</span>:<span class="hljs-string">'user@example.com'</span>});
    }]
}, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, results)</span> </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'err = '</span>, err);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'results = '</span>, results);
});
</code></pre><p>This is a fairly trivial example, but to do this using the basic parallel and<br>series functions would look like this:</p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;async.parallel([
    function(callback){
        console.log('in get_data');
        // async code to get some data
        callback(null, 'data', 'converted to array');
    },
    function(callback){
        console.log('in make_folder');
        // async code to create a directory to store a file in
        // this is run at the same time as getting the data
        callback(null, 'folder');
    }
],
function(err, results){
    async.series([
        function(callback){
            console.log('in write_file', JSON.stringify(results));
            // once there is some data and the directory exists,
            // write the data to a file in the directory
            results.push('filename');
            callback(null);
        },
        function(callback){
            console.log('in email_link', JSON.stringify(results));
            // once the file is written let's email a link to it...
            callback(null, {'file':results.pop(), 'email':'user@example.com'});
        }
    ]);
});
&lt;/code&gt;&lt;/pre&gt;">async.parallel([
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callback)</span></span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'in get_data'</span>);
        <span class="hljs-comment">// async code to get some data</span>
        callback(<span class="hljs-literal">null</span>, <span class="hljs-string">'data'</span>, <span class="hljs-string">'converted to array'</span>);
    },
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callback)</span></span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'in make_folder'</span>);
        <span class="hljs-comment">// async code to create a directory to store a file in</span>
        <span class="hljs-comment">// this is run at the same time as getting the data</span>
        callback(<span class="hljs-literal">null</span>, <span class="hljs-string">'folder'</span>);
    }
],
<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, results)</span></span>{
    async.series([
        <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callback)</span></span>{
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'in write_file'</span>, <span class="hljs-built_in">JSON</span>.stringify(results));
            <span class="hljs-comment">// once there is some data and the directory exists,</span>
            <span class="hljs-comment">// write the data to a file in the directory</span>
            results.push(<span class="hljs-string">'filename'</span>);
            callback(<span class="hljs-literal">null</span>);
        },
        <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callback)</span></span>{
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'in email_link'</span>, <span class="hljs-built_in">JSON</span>.stringify(results));
            <span class="hljs-comment">// once the file is written let's email a link to it...</span>
            callback(<span class="hljs-literal">null</span>, {<span class="hljs-string">'file'</span>:results.pop(), <span class="hljs-string">'email'</span>:<span class="hljs-string">'user@example.com'</span>});
        }
    ]);
});
</code></pre><p>For a complicated series of <code>async</code> tasks, using the <a href="#auto"><code>auto</code></a> function makes adding<br>new tasks much easier (and the code more readable).</p><hr class="section"><p><a name="retry"></a></p><a name="retry">
</a><h3 id="retry([times-=-5],-task,-[callback])"><a name="retry"></a><a name="retry([times-=-5],-task,-[callback])" href="#retry([times-=-5],-task,-[callback])"></a>retry([times = 5], task, [callback])</h3><p>Attempts to get a successful response from <code>task</code> no more than <code>times</code> times before<br>returning an error. If the task is successful, the <code>callback</code> will be passed the result<br>of the successfull task. If all attemps fail, the callback will be passed the error and<br>result (if any) of the final attempt.</p><p><strong>Arguments</strong></p><ul>
<li><code>times</code> - An integer indicating how many times to attempt the <code>task</code> before giving up. Defaults to 5.</li>
<li><code>task(callback, results)</code> - A function which receives two arguments: (1) a <code>callback(err, result)</code><br>which must be called when finished, passing <code>err</code> (which can be <code>null</code>) and the <code>result</code> of<br>the function’s execution, and (2) a <code>results</code> object, containing the results of<br>the previously executed functions (if nested inside another control flow).</li>
<li><code>callback(err, results)</code> - An optional callback which is called when the<br>task has succeeded, or after the final failed attempt. It receives the <code>err</code> and <code>result</code> arguments of the last attempt at completing the <code>task</code>.</li>
</ul><p>The <a href="#retry"><code>retry</code></a> function can be used as a stand-alone control flow by passing a<br>callback, as shown below:</p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;async.retry(3, apiMethod, function(err, result) {
    // do something with the result
});
&lt;/code&gt;&lt;/pre&gt;">async.retry(<span class="hljs-number">3</span>, apiMethod, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, result)</span> </span>{
    <span class="hljs-comment">// do something with the result</span>
});
</code></pre><p>It can also be embeded within other control flow functions to retry individual methods<br>that are not as reliable, like this:</p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;async.auto({
    users: api.getUsers.bind(api),
    payments: async.retry(3, api.getPayments.bind(api))
}, function(err, results) {
  // do something with the results
});
&lt;/code&gt;&lt;/pre&gt;">async.auto({
    users: api.getUsers.bind(api),
    payments: async.retry(<span class="hljs-number">3</span>, api.getPayments.bind(api))
}, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, results)</span> </span>{
  <span class="hljs-comment">// do something with the results</span>
});
</code></pre><hr class="section"><p><a name="iterator"></a></p><a name="iterator">
</a><h3 id="iterator(tasks)"><a name="iterator"></a><a name="iterator(tasks)" href="#iterator(tasks)"></a>iterator(tasks)</h3><p>Creates an iterator function which calls the next function in the <code>tasks</code> array,<br>returning a continuation to call the next one after that. It’s also possible to<br>“peek” at the next iterator with <code>iterator.next()</code>.</p><p>This function is used internally by the <code>async</code> module, but can be useful when<br>you want to manually control the flow of functions in series.</p><p><strong>Arguments</strong></p><ul>
<li><code>tasks</code> - An array of functions to run.</li>
</ul><p><strong>Example</strong></p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;var iterator = async.iterator([
    function(){ sys.p('one'); },
    function(){ sys.p('two'); },
    function(){ sys.p('three'); }
]);

node&amp;gt; var iterator2 = iterator();
'one'
node&amp;gt; var iterator3 = iterator2();
'two'
node&amp;gt; iterator3();
'three'
node&amp;gt; var nextfn = iterator2.next();
node&amp;gt; nextfn();
'three'
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-keyword">var</span> iterator = async.iterator([
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{ sys.p(<span class="hljs-string">'one'</span>); },
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{ sys.p(<span class="hljs-string">'two'</span>); },
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{ sys.p(<span class="hljs-string">'three'</span>); }
]);

node&gt; <span class="hljs-keyword">var</span> iterator2 = iterator();
<span class="hljs-string">'one'</span>
node&gt; <span class="hljs-keyword">var</span> iterator3 = iterator2();
<span class="hljs-string">'two'</span>
node&gt; iterator3();
<span class="hljs-string">'three'</span>
node&gt; <span class="hljs-keyword">var</span> nextfn = iterator2.next();
node&gt; nextfn();
<span class="hljs-string">'three'</span>
</code></pre><hr class="section"><p><a name="apply"></a></p><a name="apply">
</a><h3 id="apply(function,-arguments..)"><a name="apply"></a><a name="apply(function,-arguments..)" href="#apply(function,-arguments..)"></a>apply(function, arguments..)</h3><p>Creates a continuation function with some arguments already applied. </p><p>Useful as a shorthand when combined with other control flow functions. Any arguments<br>passed to the returned function are added to the arguments originally passed<br>to apply.</p><p><strong>Arguments</strong></p><ul>
<li><code>function</code> - The function you want to eventually apply all arguments to.</li>
<li><code>arguments...</code> - Any number of arguments to automatically apply when the<br>continuation is called.</li>
</ul><p><strong>Example</strong></p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;// using apply

async.parallel([
    async.apply(fs.writeFile, 'testfile1', 'test1'),
    async.apply(fs.writeFile, 'testfile2', 'test2'),
]);


// the same process without using apply

async.parallel([
    function(callback){
        fs.writeFile('testfile1', 'test1', callback);
    },
    function(callback){
        fs.writeFile('testfile2', 'test2', callback);
    }
]);
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-comment">// using apply</span>

async.parallel([
    async.apply(fs.writeFile, <span class="hljs-string">'testfile1'</span>, <span class="hljs-string">'test1'</span>),
    async.apply(fs.writeFile, <span class="hljs-string">'testfile2'</span>, <span class="hljs-string">'test2'</span>),
]);


<span class="hljs-comment">// the same process without using apply</span>

async.parallel([
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callback)</span></span>{
        fs.writeFile(<span class="hljs-string">'testfile1'</span>, <span class="hljs-string">'test1'</span>, callback);
    },
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(callback)</span></span>{
        fs.writeFile(<span class="hljs-string">'testfile2'</span>, <span class="hljs-string">'test2'</span>, callback);
    }
]);
</code></pre><p>It’s possible to pass any number of additional arguments when calling the<br>continuation:</p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;node&amp;gt; var fn = async.apply(sys.puts, 'one');
node&amp;gt; fn('two', 'three');
one
two
three
&lt;/code&gt;&lt;/pre&gt;">node&gt; <span class="hljs-keyword">var</span> fn = async.apply(sys.puts, <span class="hljs-string">'one'</span>);
node&gt; fn(<span class="hljs-string">'two'</span>, <span class="hljs-string">'three'</span>);
one
two
three
</code></pre><hr class="section"><p><a name="nextTick"></a></p><a name="nextTick">
</a><h3 id="nexttick(callback)"><a name="nextTick"></a><a name="nexttick(callback)" href="#nexttick(callback)"></a>nextTick(callback)</h3><p>Calls <code>callback</code> on a later loop around the event loop. In Node.js this just<br>calls <code>process.nextTick</code>; in the browser it falls back to <code>setImmediate(callback)</code><br>if available, otherwise <code>setTimeout(callback, 0)</code>, which means other higher priority<br>events may precede the execution of <code>callback</code>.</p><p>This is used internally for browser-compatibility purposes.</p><p><strong>Arguments</strong></p><ul>
<li><code>callback</code> - The function to call on a later loop around the event loop.</li>
</ul><p><strong>Example</strong></p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;var call_order = [];
async.nextTick(function(){
    call_order.push('two');
    // call_order now equals ['one','two']
});
call_order.push('one')
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-keyword">var</span> call_order = [];
async.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    call_order.push(<span class="hljs-string">'two'</span>);
    <span class="hljs-comment">// call_order now equals ['one','two']</span>
});
call_order.push(<span class="hljs-string">'one'</span>)
</code></pre><p><a name="times"></a></p><a name="times">
</a><h3 id="times(n,-callback)"><a name="times"></a><a name="times(n,-callback)" href="#times(n,-callback)"></a>times(n, callback)</h3><p>Calls the <code>callback</code> function <code>n</code> times, and accumulates results in the same manner<br>you would use with <a href="#map"><code>map</code></a>.</p><p><strong>Arguments</strong></p><ul>
<li><code>n</code> - The number of times to run the function.</li>
<li><code>callback</code> - The function to call <code>n</code> times.</li>
</ul><p><strong>Example</strong></p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;// Pretend this is some complicated async factory
var createUser = function(id, callback) {
  callback(null, {
    id: 'user' + id
  })
}
// generate 5 users
async.times(5, function(n, next){
    createUser(n, function(err, user) {
      next(err, user)
    })
}, function(err, users) {
  // we should now have 5 users
});
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-comment">// Pretend this is some complicated async factory</span>
<span class="hljs-keyword">var</span> createUser = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(id, callback)</span> </span>{
  callback(<span class="hljs-literal">null</span>, {
    id: <span class="hljs-string">'user'</span> + id
  })
}
<span class="hljs-comment">// generate 5 users</span>
async.times(<span class="hljs-number">5</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(n, next)</span></span>{
    createUser(n, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, user)</span> </span>{
      next(err, user)
    })
}, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, users)</span> </span>{
  <span class="hljs-comment">// we should now have 5 users</span>
});
</code></pre><p><a name="timesSeries"></a></p><a name="timesSeries">
</a><h3 id="timesseries(n,-callback)"><a name="timesSeries"></a><a name="timesseries(n,-callback)" href="#timesseries(n,-callback)"></a>timesSeries(n, callback)</h3><p>The same as <a href="#times"><code>times</code></a>, only the iterator is applied to each item in <code>arr</code> in<br>series. The next <code>iterator</code> is only called once the current one has completed.<br>The results array will be in the same order as the original.</p><h2 id="utils"><a name="utils" href="#utils"></a>Utils</h2><p><a name="memoize"></a></p><a name="memoize">
</a><h3 id="memoize(fn,-[hasher])"><a name="memoize"></a><a name="memoize(fn,-[hasher])" href="#memoize(fn,-[hasher])"></a>memoize(fn, [hasher])</h3><p>Caches the results of an <code>async</code> function. When creating a hash to store function<br>results against, the callback is omitted from the hash and an optional hash<br>function can be used.</p><p>The cache of results is exposed as the <code>memo</code> property of the function returned<br>by <code>memoize</code>.</p><p><strong>Arguments</strong></p><ul>
<li><code>fn</code> - The function to proxy and cache results from.</li>
<li><code>hasher</code> - Tn optional function for generating a custom hash for storing<br>results. It has all the arguments applied to it apart from the callback, and<br>must be synchronous.</li>
</ul><p><strong>Example</strong></p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;var slow_fn = function (name, callback) {
    // do something
    callback(null, result);
};
var fn = async.memoize(slow_fn);

// fn can now be used as if it were slow_fn
fn('some name', function () {
    // callback
});
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-keyword">var</span> slow_fn = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, callback)</span> </span>{
    <span class="hljs-comment">// do something</span>
    callback(<span class="hljs-literal">null</span>, result);
};
<span class="hljs-keyword">var</span> fn = async.memoize(slow_fn);

<span class="hljs-comment">// fn can now be used as if it were slow_fn</span>
fn(<span class="hljs-string">'some name'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// callback</span>
});
</code></pre><p><a name="unmemoize"></a></p><a name="unmemoize">
</a><h3 id="unmemoize(fn)"><a name="unmemoize"></a><a name="unmemoize(fn)" href="#unmemoize(fn)"></a>unmemoize(fn)</h3><p>Undoes a <a href="#memoize"><code>memoize</code></a>d function, reverting it to the original, unmemoized<br>form. Handy for testing.</p><p><strong>Arguments</strong></p><ul>
<li><code>fn</code> - the memoized function</li>
</ul><p><a name="log"></a></p><a name="log">
</a><h3 id="log(function,-arguments)"><a name="log"></a><a name="log(function,-arguments)" href="#log(function,-arguments)"></a>log(function, arguments)</h3><p>Logs the result of an <code>async</code> function to the <code>console</code>. Only works in Node.js or<br>in browsers that support <code>console.log</code> and <code>console.error</code> (such as FF and Chrome).<br>If multiple arguments are returned from the async function, <code>console.log</code> is<br>called on each argument in order.</p><p><strong>Arguments</strong></p><ul>
<li><code>function</code> - The function you want to eventually apply all arguments to.</li>
<li><code>arguments...</code> - Any number of arguments to apply to the function.</li>
</ul><p><strong>Example</strong></p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;var hello = function(name, callback){
    setTimeout(function(){
        callback(null, 'hello ' + name);
    }, 1000);
};
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-keyword">var</span> hello = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(name, callback)</span></span>{
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
        callback(<span class="hljs-literal">null</span>, <span class="hljs-string">'hello '</span> + name);
    }, <span class="hljs-number">1000</span>);
};
</code></pre><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;node&amp;gt; async.log(hello, 'world');
'hello world'
&lt;/code&gt;&lt;/pre&gt;">node&gt; async.log(hello, <span class="hljs-string">'world'</span>);
<span class="hljs-string">'hello world'</span>
</code></pre><hr class="section"><p><a name="dir"></a></p><a name="dir">
</a><h3 id="dir(function,-arguments)"><a name="dir"></a><a name="dir(function,-arguments)" href="#dir(function,-arguments)"></a>dir(function, arguments)</h3><p>Logs the result of an <code>async</code> function to the <code>console</code> using <code>console.dir</code> to<br>display the properties of the resulting object. Only works in Node.js or<br>in browsers that support <code>console.dir</code> and <code>console.error</code> (such as FF and Chrome).<br>If multiple arguments are returned from the async function, <code>console.dir</code> is<br>called on each argument in order.</p><p><strong>Arguments</strong></p><ul>
<li><code>function</code> - The function you want to eventually apply all arguments to.</li>
<li><code>arguments...</code> - Any number of arguments to apply to the function.</li>
</ul><p><strong>Example</strong></p><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;var hello = function(name, callback){
    setTimeout(function(){
        callback(null, {hello: name});
    }, 1000);
};
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-keyword">var</span> hello = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(name, callback)</span></span>{
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
        callback(<span class="hljs-literal">null</span>, {hello: name});
    }, <span class="hljs-number">1000</span>);
};
</code></pre><pre><code class="js hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;node&amp;gt; async.dir(hello, 'world');
{hello: 'world'}
&lt;/code&gt;&lt;/pre&gt;">node&gt; async.dir(hello, <span class="hljs-string">'world'</span>);
{hello: <span class="hljs-string">'world'</span>}
</code></pre><hr class="section"><p><a name="noConflict"></a></p><a name="noConflict">
</a><h3 id="noconflict()"><a name="noConflict"></a><a name="noconflict()" href="#noconflict()"></a>noConflict()</h3><p>Changes the value of <code>async</code> back to its original value, returning a reference to the<br><code>async</code> object.</p>

<footer style="position:fixed; font-size:.8em; text-align:right; bottom:0px; margin-left:-25px; height:20px; width:100%;">generated by <a href="http://pad.haroopress.com" target="_blank">haroopad</a></footer>
</body>
</html>
